<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NovaEngine 2D</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&family=Syne:wght@400;600;800&display=swap');

:root {
  --bg: #0b0c0f;
  --bg2: #111318;
  --panel: #13151a;
  --surface: #1a1c22;
  --surface2: #22252e;
  --border: #2a2d38;
  --border2: #363a48;
  --text: #d4d8e8;
  --text2: #8892a8;
  --text3: #555f7a;
  --cyan: #00d4ff;
  --cyan2: #00a8cc;
  --purple: #8b5cf6;
  --green: #22d67a;
  --orange: #f97316;
  --red: #f43f5e;
  --yellow: #fbbf24;
  --blue: #3b82f6;
  --kw: #c792ea;
  --str: #a3e635;
  --num: #f97316;
  --cmt: #4a5568;
  --fn: #60a5fa;
  --type: #7dd3fc;
  --sel: rgba(0,212,255,0.15);
}

* { margin:0; padding:0; box-sizing:border-box; }

body {
  font-family: 'JetBrains Mono', monospace;
  background: var(--bg);
  color: var(--text);
  overflow: hidden;
  height: 100vh;
  width: 100vw;
  display: flex;
  flex-direction: column;
  font-size: 12px;
  user-select: none;
}

/* MENU BAR */
#menubar {
  height: 30px;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 8px;
  gap: 2px;
  flex-shrink: 0;
  z-index: 100;
}

#logo {
  font-family: 'Syne', sans-serif;
  font-weight: 800;
  font-size: 14px;
  color: var(--cyan);
  margin-right: 12px;
  letter-spacing: 2px;
  text-shadow: 0 0 20px rgba(0,212,255,0.5);
}

.menu-item {
  padding: 4px 10px;
  border-radius: 3px;
  cursor: pointer;
  color: var(--text2);
  font-size: 11px;
  position: relative;
}
.menu-item:hover { background: var(--surface); color: var(--text); }

.menu-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 4px;
  min-width: 180px;
  z-index: 1000;
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
}
.menu-item:hover .menu-dropdown { display: block; }

.menu-dropdown-item {
  padding: 7px 14px;
  cursor: pointer;
  color: var(--text2);
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.menu-dropdown-item:hover { background: var(--surface); color: var(--text); }
.menu-dropdown-item .shortcut { color: var(--text3); font-size: 10px; }

.menu-sep { height: 1px; background: var(--border); margin: 2px 0; }

.menu-spacer { flex: 1; }

/* TOOLBAR */
#toolbar {
  height: 36px;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 8px;
  gap: 2px;
  flex-shrink: 0;
}

.tb-btn {
  height: 26px;
  padding: 0 10px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text2);
  cursor: pointer;
  font-family: inherit;
  font-size: 11px;
  display: flex;
  align-items: center;
  gap: 5px;
  transition: all 0.15s;
}
.tb-btn:hover { background: var(--surface2); color: var(--text); border-color: var(--border2); }
.tb-btn.active { background: rgba(0,212,255,0.15); color: var(--cyan); border-color: rgba(0,212,255,0.4); }
.tb-btn.primary { background: var(--cyan2); color: #000; border-color: var(--cyan); font-weight: 600; }
.tb-btn.primary:hover { background: var(--cyan); }
.tb-btn.danger { background: rgba(244,63,94,0.15); color: var(--red); border-color: rgba(244,63,94,0.4); }
.tb-btn.danger:hover { background: rgba(244,63,94,0.25); }

.tb-sep { width: 1px; height: 20px; background: var(--border); margin: 0 4px; }

.tb-label { color: var(--text3); font-size: 10px; padding: 0 6px; }

/* MAIN LAYOUT */
#main {
  flex: 1;
  display: flex;
  overflow: hidden;
}

/* PANELS */
.panel {
  background: var(--panel);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.panel-header {
  height: 28px;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 10px;
  gap: 6px;
  flex-shrink: 0;
}

.panel-title {
  font-size: 10px;
  font-weight: 600;
  color: var(--text2);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.panel-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
  background: var(--bg2);
  flex-shrink: 0;
}

.panel-tab {
  padding: 6px 14px;
  font-size: 10px;
  font-weight: 500;
  color: var(--text3);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  transition: all 0.15s;
}
.panel-tab:hover { color: var(--text2); }
.panel-tab.active { color: var(--cyan); border-bottom-color: var(--cyan); }

/* LEFT PANEL */
#left-panel { width: 220px; flex-shrink: 0; }

/* SCENE TREE */
#scene-tree {
  flex: 1;
  overflow-y: auto;
  padding: 4px 0;
}

.tree-node {
  display: flex;
  align-items: center;
  height: 24px;
  padding-right: 8px;
  cursor: pointer;
  position: relative;
  transition: background 0.1s;
}
.tree-node:hover { background: var(--surface); }
.tree-node.selected { background: var(--sel) !important; }
.tree-node.selected::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 2px;
  background: var(--cyan);
}

.tree-indent { display: flex; align-items: center; }
.tree-arrow {
  width: 14px;
  height: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text3);
  font-size: 8px;
  transition: transform 0.2s;
}
.tree-arrow.expanded { transform: rotate(90deg); }
.tree-spacer { width: 14px; }

.tree-icon {
  width: 16px;
  height: 16px;
  margin: 0 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  flex-shrink: 0;
}

.tree-name {
  flex: 1;
  font-size: 11px;
  color: var(--text);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.tree-type {
  font-size: 9px;
  color: var(--text3);
  padding: 1px 5px;
  background: var(--surface);
  border-radius: 3px;
  margin-left: 4px;
}

/* NODE LIBRARY */
#node-library {
  padding: 6px;
  overflow-y: auto;
}

.node-search {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-family: inherit;
  font-size: 11px;
  padding: 5px 8px;
  margin-bottom: 8px;
  outline: none;
}
.node-search:focus { border-color: var(--cyan2); }

.node-category {
  margin-bottom: 8px;
}

.node-cat-header {
  font-size: 9px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text3);
  padding: 2px 4px;
  margin-bottom: 3px;
  display: flex;
  align-items: center;
  gap: 5px;
  cursor: pointer;
}
.node-cat-header::after { content: '‚ñæ'; margin-left: auto; }

.node-items {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 3px;
}

.node-btn {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 5px 7px;
  cursor: pointer;
  font-size: 10px;
  color: var(--text2);
  display: flex;
  align-items: center;
  gap: 4px;
  transition: all 0.15s;
  font-family: inherit;
}
.node-btn:hover { background: var(--surface2); color: var(--text); border-color: var(--border2); }

/* CENTER - VIEWPORT */
#center { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

#viewport-header {
  height: 28px;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 8px;
  gap: 6px;
  flex-shrink: 0;
}

.vp-mode-btn {
  padding: 3px 8px;
  border-radius: 3px;
  font-size: 10px;
  cursor: pointer;
  color: var(--text3);
  font-family: inherit;
  border: none;
  background: none;
}
.vp-mode-btn.active { background: var(--surface); color: var(--cyan); }

#viewport-container {
  flex: 1;
  position: relative;
  background: #0a0b0e;
  overflow: hidden;
  cursor: crosshair;
}

#viewport-canvas {
  position: absolute;
  top: 0; left: 0;
  image-rendering: pixelated;
}

#game-canvas {
  position: absolute;
  top: 0; left: 0;
  display: none;
}

.vp-overlay {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  pointer-events: none;
}

.vp-info {
  background: rgba(13,14,15,0.85);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 10px;
  color: var(--text2);
}

/* BOTTOM */
#bottom {
  height: 200px;
  border-top: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
}

#editor-area {
  flex: 1;
  display: flex;
  overflow: hidden;
}

#code-editor-wrapper {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#code-editor-header {
  height: 28px;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 8px;
  gap: 8px;
  flex-shrink: 0;
}

.editor-file-tab {
  padding: 4px 12px;
  border-radius: 3px 3px 0 0;
  font-size: 10px;
  cursor: pointer;
  color: var(--text3);
  border: 1px solid transparent;
  display: flex;
  align-items: center;
  gap: 5px;
}
.editor-file-tab.active {
  background: var(--panel);
  color: var(--text);
  border-color: var(--border);
  border-bottom-color: var(--panel);
}

#code-editor-container {
  flex: 1;
  display: flex;
  overflow: hidden;
  position: relative;
}

#line-numbers {
  background: var(--bg2);
  border-right: 1px solid var(--border);
  padding: 8px 4px;
  min-width: 40px;
  text-align: right;
  font-size: 11px;
  line-height: 1.6;
  color: var(--text3);
  overflow: hidden;
  flex-shrink: 0;
  user-select: none;
}

#code-editor {
  flex: 1;
  background: transparent;
  color: transparent;
  caret-color: var(--cyan);
  border: none;
  outline: none;
  padding: 8px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  line-height: 1.6;
  resize: none;
  tab-size: 4;
  position: absolute;
  top: 0; left: 40px; right: 0; bottom: 0;
  white-space: pre;
  overflow: auto;
  z-index: 2;
}

#code-highlight {
  position: absolute;
  top: 0; left: 40px; right: 0; bottom: 0;
  padding: 8px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  line-height: 1.6;
  pointer-events: none;
  white-space: pre;
  overflow: hidden;
  z-index: 1;
  color: var(--text);
}

/* Syntax highlighting */
.tok-kw { color: var(--kw); font-style: italic; }
.tok-str { color: var(--str); }
.tok-num { color: var(--num); }
.tok-cmt { color: var(--cmt); font-style: italic; }
.tok-fn { color: var(--fn); }
.tok-type { color: var(--type); }
.tok-op { color: var(--cyan); }
.tok-self { color: var(--purple); font-style: italic; }
.tok-builtin { color: var(--yellow); }

/* CONSOLE */
#console-panel {
  width: 300px;
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
}

#console-output {
  flex: 1;
  overflow-y: auto;
  padding: 6px;
  font-size: 10px;
  line-height: 1.7;
}

.log-line { color: var(--text2); }
.log-warn { color: var(--yellow); }
.log-error { color: var(--red); }
.log-info { color: var(--cyan); }
.log-success { color: var(--green); }
.log-sys { color: var(--purple); }

/* RIGHT PANEL - INSPECTOR */
#right-panel { width: 260px; flex-shrink: 0; border-left: 1px solid var(--border); border-right: none; }

#inspector {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.inspector-section {
  margin-bottom: 12px;
}

.inspector-section-header {
  font-size: 9px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text3);
  padding: 4px 0;
  border-bottom: 1px solid var(--border);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 5px;
  cursor: pointer;
}

.prop-row {
  display: flex;
  align-items: center;
  margin-bottom: 5px;
  gap: 6px;
}

.prop-label {
  width: 90px;
  font-size: 10px;
  color: var(--text2);
  flex-shrink: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.prop-input {
  flex: 1;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 2px;
  color: var(--text);
  font-family: inherit;
  font-size: 11px;
  padding: 3px 6px;
  outline: none;
  min-width: 0;
}
.prop-input:focus { border-color: var(--cyan2); }

.prop-input[type="color"] {
  padding: 1px 2px;
  width: 36px;
  height: 22px;
  cursor: pointer;
}

.prop-input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: var(--cyan);
}

.prop-vec2 { display: flex; gap: 3px; flex: 1; }
.prop-vec2 input { flex: 1; min-width: 0; }

.prop-range { display: flex; gap: 4px; flex: 1; align-items: center; }
.prop-range input[type=range] { flex: 1; accent-color: var(--cyan); }
.prop-range .range-val { width: 36px; text-align: right; }

.prop-select {
  flex: 1;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 2px;
  color: var(--text);
  font-family: inherit;
  font-size: 11px;
  padding: 3px 6px;
  outline: none;
}
.prop-select:focus { border-color: var(--cyan2); }

.node-name-input {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--cyan);
  font-family: 'Syne', sans-serif;
  font-size: 14px;
  font-weight: 600;
  padding: 6px 8px;
  width: 100%;
  outline: none;
  margin-bottom: 8px;
}
.node-name-input:focus { border-color: var(--cyan); }

.node-type-badge {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 3px 8px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 3px;
  font-size: 10px;
  color: var(--type);
  margin-bottom: 10px;
}

/* SCROLLBAR */
::-webkit-scrollbar { width: 4px; height: 4px; }
::-webkit-scrollbar-track { background: var(--bg2); }
::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }
::-webkit-scrollbar-thumb:hover { background: var(--text3); }

/* RESIZER */
.resizer {
  width: 4px;
  background: var(--border);
  cursor: col-resize;
  flex-shrink: 0;
  transition: background 0.15s;
}
.resizer:hover, .resizer.dragging { background: var(--cyan2); }

.resizer-h {
  height: 4px;
  background: var(--border);
  cursor: row-resize;
  flex-shrink: 0;
}
.resizer-h:hover, .resizer-h.dragging { background: var(--cyan2); }

/* MODAL */
.modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 200;
  align-items: center;
  justify-content: center;
}
.modal-overlay.open { display: flex; }

.modal {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 6px;
  width: 500px;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6);
}

.modal-header {
  padding: 14px 18px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.modal-title {
  font-family: 'Syne', sans-serif;
  font-weight: 600;
  font-size: 14px;
  color: var(--text);
}

.modal-close {
  width: 24px;
  height: 24px;
  background: var(--surface);
  border: none;
  border-radius: 3px;
  color: var(--text2);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-family: inherit;
}
.modal-close:hover { background: var(--surface2); color: var(--text); }

.modal-body { padding: 16px 18px; overflow-y: auto; }
.modal-footer { padding: 12px 18px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 8px; }

/* NODE ADD GRID */
.node-add-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin-top: 12px;
}

.node-add-item {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 10px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  transition: all 0.15s;
  text-align: center;
}
.node-add-item:hover { background: var(--surface2); border-color: var(--cyan2); }
.node-add-item.selected { background: rgba(0,212,255,0.1); border-color: var(--cyan); }
.node-add-item .icon { font-size: 20px; }
.node-add-item .name { font-size: 10px; color: var(--text); font-weight: 500; }
.node-add-item .desc { font-size: 9px; color: var(--text3); }

/* SHADER EDITOR */
#shader-panel {
  width: 320px;
  border-left: 1px solid var(--border);
  display: none;
  flex-direction: column;
}

/* AI ASSISTANT */
#ai-panel {
  width: 300px;
  border-left: 1px solid var(--border);
  display: none;
  flex-direction: column;
  flex-shrink: 0;
  background: var(--panel);
}

.ai-messages {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.ai-msg {
  padding: 8px 10px;
  border-radius: 4px;
  font-size: 11px;
  line-height: 1.5;
}
.ai-msg.user { background: var(--surface2); color: var(--text); align-self: flex-end; max-width: 90%; }
.ai-msg.ai { background: rgba(0,212,255,0.08); border: 1px solid rgba(0,212,255,0.2); color: var(--text); }

.ai-input-row {
  display: flex;
  gap: 6px;
  padding: 8px;
  border-top: 1px solid var(--border);
}

.ai-input {
  flex: 1;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-family: inherit;
  font-size: 11px;
  padding: 5px 8px;
  outline: none;
  resize: none;
  height: 28px;
}
.ai-input:focus { border-color: var(--cyan2); }

/* TOOLTIP */
.tooltip {
  position: absolute;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 4px 8px;
  font-size: 10px;
  color: var(--text2);
  pointer-events: none;
  z-index: 1000;
  white-space: nowrap;
}

/* Context menu */
.context-menu {
  display: none;
  position: fixed;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 4px;
  min-width: 160px;
  z-index: 500;
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
}
.context-menu.open { display: block; }
.ctx-item {
  padding: 7px 14px;
  cursor: pointer;
  font-size: 11px;
  color: var(--text2);
  display: flex;
  align-items: center;
  gap: 8px;
}
.ctx-item:hover { background: var(--surface); color: var(--text); }
.ctx-item.danger { color: var(--red); }
.ctx-sep { height: 1px; background: var(--border); margin: 3px 0; }

/* STATUS BAR */
#statusbar {
  height: 22px;
  background: var(--bg2);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 10px;
  gap: 12px;
  flex-shrink: 0;
  font-size: 10px;
  color: var(--text3);
}

.status-item {
  display: flex;
  align-items: center;
  gap: 4px;
}

.status-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--green);
  animation: pulse-dot 2s infinite;
}

@keyframes pulse-dot {
  0%,100% { opacity:1; }
  50% { opacity:0.4; }
}

/* ANIMATION in viewport */
.vp-gizmo {
  position: absolute;
  pointer-events: none;
}

/* GRID BACKGROUND */
.vp-grid {
  background-image:
    linear-gradient(rgba(42,45,56,0.4) 1px, transparent 1px),
    linear-gradient(90deg, rgba(42,45,56,0.4) 1px, transparent 1px);
  background-size: 20px 20px;
}

/* ANIMATION PANEL */
#anim-panel {
  border-top: 1px solid var(--border);
  height: 120px;
  background: var(--bg2);
  display: none;
  flex-direction: column;
  flex-shrink: 0;
}

.anim-header {
  height: 28px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 8px;
  gap: 6px;
}

.anim-timeline {
  flex: 1;
  display: flex;
  overflow: hidden;
}

.anim-tracks {
  width: 160px;
  border-right: 1px solid var(--border);
  overflow-y: auto;
}

.anim-track {
  height: 24px;
  display: flex;
  align-items: center;
  padding: 0 8px;
  border-bottom: 1px solid rgba(42,45,56,0.5);
  font-size: 10px;
  color: var(--text2);
}

.anim-keys {
  flex: 1;
  position: relative;
  overflow-x: auto;
}

.anim-ruler {
  height: 20px;
  border-bottom: 1px solid var(--border);
  background: var(--bg2);
  position: relative;
}

.keyframe {
  width: 8px;
  height: 8px;
  background: var(--cyan);
  border-radius: 50%;
  position: absolute;
  top: 50%;
  transform: translate(-50%, -50%);
  cursor: pointer;
}

/* Run button glow */
.run-btn-glow {
  box-shadow: 0 0 12px rgba(34,214,122,0.4);
  background: rgba(34,214,122,0.2) !important;
  color: var(--green) !important;
  border-color: rgba(34,214,122,0.5) !important;
}

/* Loading spinner */
@keyframes spin {
  to { transform: rotate(360deg); }
}
.spinner {
  width: 12px;
  height: 12px;
  border: 2px solid var(--border);
  border-top-color: var(--cyan);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

/* Physics debug overlay */
.phys-debug rect, .phys-debug circle {
  fill: none;
  stroke: rgba(244,63,94,0.7);
  stroke-width: 1;
}
</style>
</head>
<body>

<!-- MENU BAR -->
<div id="menubar">
  <div id="logo">NOVA<span style="color:var(--purple)">2D</span></div>
  <div class="menu-item">File
    <div class="menu-dropdown">
      <div class="menu-dropdown-item" onclick="newProject()">New Project <span class="shortcut">Ctrl+N</span></div>
      <div class="menu-dropdown-item" onclick="saveProject()">Save <span class="shortcut">Ctrl+S</span></div>
      <div class="menu-dropdown-item" onclick="loadProject()">Open... <span class="shortcut">Ctrl+O</span></div>
      <div class="menu-sep"></div>
      <div class="menu-dropdown-item" onclick="exportGame()">Export Game</div>
    </div>
  </div>
  <div class="menu-item">Edit
    <div class="menu-dropdown">
      <div class="menu-dropdown-item" onclick="undo()">Undo <span class="shortcut">Ctrl+Z</span></div>
      <div class="menu-dropdown-item" onclick="redo()">Redo <span class="shortcut">Ctrl+Y</span></div>
      <div class="menu-sep"></div>
      <div class="menu-dropdown-item" onclick="duplicateNode()">Duplicate Node <span class="shortcut">Ctrl+D</span></div>
      <div class="menu-dropdown-item" onclick="deleteSelectedNode()">Delete Node <span class="shortcut">Del</span></div>
    </div>
  </div>
  <div class="menu-item">Scene
    <div class="menu-dropdown">
      <div class="menu-dropdown-item" onclick="showAddNodeModal()">Add Node <span class="shortcut">Ctrl+A</span></div>
      <div class="menu-dropdown-item" onclick="clearScene()">Clear Scene</div>
      <div class="menu-sep"></div>
      <div class="menu-dropdown-item" onclick="loadDemoScene()">Load Demo Scene</div>
    </div>
  </div>
  <div class="menu-item">View
    <div class="menu-dropdown">
      <div class="menu-dropdown-item" onclick="toggleGrid()">Toggle Grid</div>
      <div class="menu-dropdown-item" onclick="togglePhysicsDebug()">Physics Debug</div>
      <div class="menu-dropdown-item" onclick="toggleAIPanel()">AI Assistant</div>
      <div class="menu-dropdown-item" onclick="toggleAnimPanel()">Animation Panel</div>
      <div class="menu-dropdown-item" onclick="toggleShaderPanel()">Shader Editor</div>
      <div class="menu-sep"></div>
      <div class="menu-dropdown-item" onclick="resetViewport()">Reset Camera</div>
    </div>
  </div>
  <div class="menu-item">Project
    <div class="menu-dropdown">
      <div class="menu-dropdown-item" onclick="showProjectSettings()">Project Settings</div>
      <div class="menu-dropdown-item" onclick="addScript()">New Script</div>
    </div>
  </div>
  <div class="menu-spacer"></div>
  <div style="font-size:10px; color:var(--text3)">NovaEngine 2D v1.0</div>
</div>

<!-- TOOLBAR -->
<div id="toolbar">
  <button class="tb-btn" onclick="showAddNodeModal()">‚äï Add Node</button>
  <div class="tb-sep"></div>
  <button class="tb-btn" id="tool-select" onclick="setTool('select')" style="color:var(--cyan)">‚Üñ Select</button>
  <button class="tb-btn" id="tool-move" onclick="setTool('move')">‚ú• Move</button>
  <button class="tb-btn" id="tool-rotate" onclick="setTool('rotate')">‚Üª Rotate</button>
  <button class="tb-btn" id="tool-scale" onclick="setTool('scale')">‚§° Scale</button>
  <div class="tb-sep"></div>
  <button class="tb-btn" onclick="snapToggle()" id="snap-btn">‚ä° Snap</button>
  <button class="tb-btn" onclick="toggleGrid()">‚äû Grid</button>
  <div class="tb-sep"></div>
  <button class="tb-btn" onclick="togglePhysicsDebug()">‚¨° Physics</button>
  <button class="tb-btn" onclick="toggleShaderPanel()">‚óà Shaders</button>
  <button class="tb-btn" onclick="toggleAnimPanel()">‚ñ∂ Animate</button>
  <button class="tb-btn" onclick="toggleAIPanel()">‚ú¶ AI</button>
  <div class="tb-sep"></div>
  <div class="menu-spacer"></div>
  <button class="tb-btn" id="run-btn" onclick="toggleRun()" style="color:var(--green)">‚ñ∂ Run</button>
  <button class="tb-btn" id="pause-btn" onclick="togglePause()" style="color:var(--yellow)">‚è∏ Pause</button>
  <button class="tb-btn danger" onclick="stopRun()">‚ñ† Stop</button>
</div>

<!-- MAIN -->
<div id="main">

  <!-- LEFT PANEL -->
  <div class="panel" id="left-panel">
    <div class="panel-tabs">
      <div class="panel-tab active" onclick="switchLeftTab('scene')" id="tab-scene">Scene</div>
      <div class="panel-tab" onclick="switchLeftTab('nodes')" id="tab-nodes">Nodes</div>
      <div class="panel-tab" onclick="switchLeftTab('assets')" id="tab-assets">Assets</div>
    </div>

    <!-- Scene Tree -->
    <div id="left-scene" style="display:flex;flex-direction:column;flex:1;overflow:hidden;">
      <div style="padding:4px 6px; display:flex; gap:4px; border-bottom:1px solid var(--border); flex-shrink:0;">
        <button class="tb-btn" style="flex:1;font-size:10px;" onclick="showAddNodeModal()">‚äï Add</button>
        <button class="tb-btn" style="font-size:10px;" onclick="deleteSelectedNode()">‚äñ</button>
        <button class="tb-btn" style="font-size:10px;" onclick="duplicateNode()">‚äï‚äï</button>
      </div>
      <div id="scene-tree"></div>
    </div>

    <!-- Node Library -->
    <div id="left-nodes" style="display:none;flex:1;overflow:hidden;flex-direction:column;">
      <div id="node-library">
        <input class="node-search" type="text" placeholder="Search nodes..." oninput="filterNodes(this.value)">
        <div id="node-categories"></div>
      </div>
    </div>

    <!-- Assets -->
    <div id="left-assets" style="display:none;flex:1;overflow:hidden;flex-direction:column;">
      <div style="padding:10px; color:var(--text3); font-size:11px; text-align:center; margin-top:20px;">
        <div style="font-size:24px;margin-bottom:8px;">üìÅ</div>
        Drop files here<br>or use Import
      </div>
      <div style="padding:6px;">
        <button class="tb-btn" style="width:100%;justify-content:center;" onclick="importAsset()">‚äï Import Asset</button>
      </div>
      <div id="asset-list" style="padding:6px; overflow-y:auto; flex:1;"></div>
    </div>
  </div>

  <div class="resizer" id="left-resizer"></div>

  <!-- CENTER -->
  <div id="center">
    <div id="viewport-header">
      <button class="vp-mode-btn active" onclick="setViewMode('2d')" id="vm-2d">2D</button>
      <button class="vp-mode-btn" onclick="setViewMode('ui')" id="vm-ui">UI</button>
      <div style="flex:1"></div>
      <span style="font-size:10px;color:var(--text3)" id="vp-coords">0, 0</span>
      <span style="font-size:10px;color:var(--text3)">|</span>
      <span style="font-size:10px;color:var(--text3)" id="vp-zoom">100%</span>
    </div>

    <div id="viewport-container" class="vp-grid"
      onmousemove="viewportMouseMove(event)"
      onmousedown="viewportMouseDown(event)"
      onmouseup="viewportMouseUp(event)"
      onwheel="viewportWheel(event)"
      oncontextmenu="viewportContextMenu(event)">
      <canvas id="viewport-canvas"></canvas>
      <canvas id="game-canvas"></canvas>
      <div class="vp-overlay">
        <div class="vp-info" id="fps-counter">FPS: --</div>
        <div class="vp-info" id="node-count">Nodes: 0</div>
      </div>
    </div>

    <!-- ANIMATION PANEL -->
    <div id="anim-panel">
      <div class="anim-header">
        <span style="font-size:10px;font-weight:600;color:var(--text2);text-transform:uppercase;letter-spacing:1px">Animation</span>
        <button class="tb-btn" onclick="addAnimTrack()">+ Track</button>
        <button class="tb-btn" onclick="addKeyframe()">‚óÜ Key</button>
        <select class="prop-select" style="width:120px;" id="anim-select">
          <option>idle</option><option>walk</option><option>jump</option>
        </select>
        <button class="tb-btn" onclick="playAnim()">‚ñ∂ Play</button>
        <div style="flex:1"></div>
        <button class="tb-btn" onclick="toggleAnimPanel()">‚úï</button>
      </div>
      <div class="anim-timeline">
        <div class="anim-tracks" id="anim-tracks"></div>
        <div class="anim-keys">
          <div class="anim-ruler" id="anim-ruler"></div>
          <div id="anim-keyframes" style="position:relative;flex:1;"></div>
        </div>
      </div>
    </div>

    <!-- BOTTOM: CODE + CONSOLE -->
    <div id="bottom">
      <div class="resizer-h" id="bottom-resizer"></div>
      <div id="editor-area">
        <div id="code-editor-wrapper">
          <div id="code-editor-header">
            <span style="font-size:10px;color:var(--text3);font-weight:600;text-transform:uppercase;letter-spacing:1px">Script</span>
            <div id="editor-tabs" style="display:flex;gap:2px;flex:1;"></div>
            <button class="tb-btn" onclick="runScript()" style="font-size:10px;color:var(--green)">‚ñ∂ Run</button>
            <button class="tb-btn" onclick="aiFixCode()" style="font-size:10px;color:var(--purple)">‚ú¶ AI Fix</button>
          </div>
          <div id="code-editor-container">
            <div id="line-numbers">1</div>
            <div id="code-highlight"></div>
            <textarea id="code-editor" spellcheck="false"
              oninput="onCodeInput()"
              onkeydown="onCodeKeydown(event)"
              onscroll="syncScroll()"></textarea>
          </div>
        </div>

        <!-- SHADER PANEL -->
        <div id="shader-panel">
          <div class="panel-header">
            <span class="panel-title">Shader Editor</span>
            <div style="flex:1"></div>
            <button class="tb-btn" style="font-size:10px;" onclick="applyShader()">Apply</button>
            <button class="tb-btn" style="font-size:10px;" onclick="toggleShaderPanel()">‚úï</button>
          </div>
          <div class="panel-tabs">
            <div class="panel-tab active" onclick="switchShaderTab('fragment')" id="st-frag">Fragment</div>
            <div class="panel-tab" onclick="switchShaderTab('vertex')" id="st-vert">Vertex</div>
          </div>
          <textarea id="shader-editor" style="flex:1;background:var(--bg);color:var(--text);border:none;outline:none;padding:8px;font-family:'JetBrains Mono',monospace;font-size:10px;line-height:1.5;resize:none;tab-size:4;"></textarea>
          <div id="shader-error" style="padding:4px 8px;font-size:10px;color:var(--red);display:none;"></div>
          <div style="padding:6px;border-top:1px solid var(--border);">
            <div style="font-size:9px;color:var(--text3);font-weight:600;text-transform:uppercase;letter-spacing:1px;margin-bottom:6px;">Uniforms</div>
            <div id="shader-uniforms"></div>
            <div style="font-size:9px;color:var(--text3);margin-top:6px;">Built-ins: u_time, u_resolution, u_color</div>
          </div>
        </div>

        <!-- AI PANEL -->
        <div id="ai-panel">
          <div class="panel-header">
            <span class="panel-title" style="color:var(--purple)">‚ú¶ AI Assistant</span>
            <div style="flex:1"></div>
            <button class="tb-btn" onclick="toggleAIPanel()">‚úï</button>
          </div>
          <div class="ai-messages" id="ai-messages">
            <div class="ai-msg ai">üëã Hi! I'm the NovaEngine AI. I can help you:<br><br>
              ‚Ä¢ Fix bugs in your NovaScript<br>
              ‚Ä¢ Generate node setups<br>
              ‚Ä¢ Create shaders<br>
              ‚Ä¢ Explain engine features<br>
              ‚Ä¢ Optimize your scene<br><br>
              Ask me anything!
            </div>
          </div>
          <div class="ai-input-row">
            <textarea class="ai-input" id="ai-input" placeholder="Ask the AI..." onkeydown="aiKeydown(event)"></textarea>
            <button class="tb-btn primary" onclick="sendAIMessage()">‚ñ∂</button>
          </div>
        </div>

        <div id="console-panel">
          <div class="panel-header">
            <span class="panel-title">Console</span>
            <div style="flex:1"></div>
            <button class="tb-btn" style="font-size:10px;" onclick="clearConsole()">Clear</button>
          </div>
          <div id="console-output"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="resizer" id="right-resizer"></div>

  <!-- RIGHT PANEL - INSPECTOR -->
  <div class="panel" id="right-panel">
    <div class="panel-tabs">
      <div class="panel-tab active" onclick="switchRightTab('inspector')" id="rt-inspector">Inspector</div>
      <div class="panel-tab" onclick="switchRightTab('signal')" id="rt-signal">Signals</div>
      <div class="panel-tab" onclick="switchRightTab('script')" id="rt-script">Script</div>
    </div>
    <div id="inspector">
      <div style="color:var(--text3);font-size:11px;text-align:center;padding:20px;">
        Select a node to inspect
      </div>
    </div>
  </div>

</div>

<!-- STATUS BAR -->
<div id="statusbar">
  <div class="status-item"><div class="status-dot"></div>Ready</div>
  <div class="status-item">Scene: <span id="scene-name">untitled.scene</span></div>
  <div class="status-item">Script: <span id="script-name">main.nova</span></div>
  <div class="status-item" id="physics-status">Physics: Off</div>
  <div style="flex:1"></div>
  <div class="status-item" id="sel-info">No selection</div>
</div>

<!-- ADD NODE MODAL -->
<div class="modal-overlay" id="add-node-modal">
  <div class="modal">
    <div class="modal-header">
      <span class="modal-title">Add Node</span>
      <button class="modal-close" onclick="closeModal('add-node-modal')">‚úï</button>
    </div>
    <div class="modal-body">
      <input class="node-search" type="text" id="node-search-modal" placeholder="Search node type..." oninput="filterAddNodes(this.value)" style="margin-bottom:12px;">
      <div id="add-node-grid" class="node-add-grid"></div>
    </div>
    <div class="modal-footer">
      <button class="tb-btn" onclick="closeModal('add-node-modal')">Cancel</button>
      <button class="tb-btn primary" id="add-node-confirm" onclick="confirmAddNode()">Add Node</button>
    </div>
  </div>
</div>

<!-- PROJECT SETTINGS MODAL -->
<div class="modal-overlay" id="settings-modal">
  <div class="modal">
    <div class="modal-header">
      <span class="modal-title">Project Settings</span>
      <button class="modal-close" onclick="closeModal('settings-modal')">‚úï</button>
    </div>
    <div class="modal-body">
      <div class="inspector-section">
        <div class="inspector-section-header">Window</div>
        <div class="prop-row"><span class="prop-label">Width</span><input class="prop-input" type="number" value="1280" id="proj-width"></div>
        <div class="prop-row"><span class="prop-label">Height</span><input class="prop-input" type="number" value="720" id="proj-height"></div>
        <div class="prop-row"><span class="prop-label">Title</span><input class="prop-input" type="text" value="My Game" id="proj-title"></div>
        <div class="prop-row"><span class="prop-label">Fullscreen</span><input class="prop-input" type="checkbox" id="proj-fullscreen"></div>
      </div>
      <div class="inspector-section">
        <div class="inspector-section-header">Physics</div>
        <div class="prop-row"><span class="prop-label">Gravity</span><input class="prop-input" type="number" value="980" id="proj-gravity"></div>
        <div class="prop-row"><span class="prop-label">Iterations</span><input class="prop-input" type="number" value="8" id="proj-iterations"></div>
        <div class="prop-row"><span class="prop-label">Debug Draw</span><input class="prop-input" type="checkbox" id="proj-phys-debug"></div>
      </div>
      <div class="inspector-section">
        <div class="inspector-section-header">Rendering</div>
        <div class="prop-row"><span class="prop-label">BG Color</span><input class="prop-input" type="color" value="#1a1b1f" id="proj-bgcolor"></div>
        <div class="prop-row"><span class="prop-label">Antialias</span><input class="prop-input" type="checkbox" checked id="proj-aa"></div>
        <div class="prop-row"><span class="prop-label">Target FPS</span><input class="prop-input" type="number" value="60" id="proj-fps"></div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="tb-btn" onclick="closeModal('settings-modal')">Cancel</button>
      <button class="tb-btn primary" onclick="applyProjectSettings()">Apply</button>
    </div>
  </div>
</div>

<!-- CONTEXT MENU -->
<div class="context-menu" id="context-menu">
  <div class="ctx-item" onclick="showAddNodeModal()">‚äï Add Child Node</div>
  <div class="ctx-item" onclick="duplicateNode()">‚äï‚äï Duplicate</div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" onclick="addScript()">üìÑ Attach Script</div>
  <div class="ctx-sep"></div>
  <div class="ctx-item danger" onclick="deleteSelectedNode()">‚äñ Delete</div>
</div>

<script>
// ============================================================
//   NOVASCRIPT ‚Äî CUSTOM SCRIPTING LANGUAGE
// ============================================================

const KW = new Set(['var','const','func','return','if','elif','else','for','while',
  'break','continue','match','case','extends','class','self','super','and','or',
  'not','in','true','false','null','pass','emit','signal','export','onready',
  'static','enum','setget','yield','await','is','as','new','delete']);

const BUILTIN_FN = new Set(['print','sin','cos','tan','sqrt','abs','floor','ceil','round',
  'min','max','clamp','lerp','sign','pow','log','exp','rand','randi','randf',
  'deg2rad','rad2deg','len','range','typeof','str','int','float','bool',
  'Vector2','Color','Rect2','Transform2D','Array','Dictionary','instance_of']);

const BUILTIN_TYPES = new Set(['Vector2','Color','Rect2','Transform2D','Node2D','Sprite2D',
  'RigidBody2D','StaticBody2D','Area2D','Camera2D','Label','Timer','Tween',
  'AnimationPlayer','PhysicsBody2D','KinematicBody2D','String','int','float','bool']);

class Lexer {
  constructor(src) {
    this.src = src; this.pos = 0; this.tokens = [];
    this.line = 1; this.col = 1;
  }
  peek(n=0) { return this.src[this.pos+n]; }
  advance() { const c = this.src[this.pos++]; if(c==='\n'){this.line++;this.col=1;}else this.col++; return c; }
  match(s) {
    if(this.src.slice(this.pos,this.pos+s.length)===s){this.pos+=s.length;return true;}
    return false;
  }
  skipWS() { while(/[ \t]/.test(this.peek())) this.advance(); }
  tokenize() {
    while(this.pos < this.src.length) {
      this.skipWS();
      if(this.pos >= this.src.length) break;
      const c = this.peek();
      const line = this.line, col = this.col;
      const tok = (t,v) => ({type:t,value:v,line,col});

      if(c === '#') {
        let s=''; while(this.pos<this.src.length && this.peek()!=='\n') s+=this.advance();
        this.tokens.push(tok('COMMENT',s)); continue;
      }
      if(c === '\n') { this.advance(); this.tokens.push(tok('NEWLINE','\n')); continue; }
      if(c === '"' || c === "'") {
        const q = this.advance(); let s='';
        while(this.pos<this.src.length && this.peek()!==q) {
          if(this.peek()==='\\') { this.advance(); const esc=this.advance(); s+=({n:'\n',t:'\t',r:'\r','\\':'\\','"':'"',"'":"'"}[esc]||esc); }
          else s+=this.advance();
        }
        this.advance(); this.tokens.push(tok('STRING',s)); continue;
      }
      if(/[0-9]/.test(c) || (c==='.' && /[0-9]/.test(this.peek(1)))) {
        let s=''; while(/[0-9._]/.test(this.peek())) s+=this.advance();
        this.tokens.push(tok('NUMBER', parseFloat(s.replace(/_/g,'')))); continue;
      }
      if(/[a-zA-Z_]/.test(c)) {
        let s=''; while(/[a-zA-Z0-9_]/.test(this.peek())) s+=this.advance();
        const type = KW.has(s) ? s.toUpperCase() : 'IDENT';
        this.tokens.push(tok(type, s)); continue;
      }
      const twoChar = this.src.slice(this.pos,this.pos+2);
      const twoMap = {'**':'POWER','==':'EQ','!=':'NEQ','<=':'LTE','>=':'GTE',
        '+=':'PLUS_ASSIGN','-=':'MINUS_ASSIGN','*=':'MUL_ASSIGN','/=':'DIV_ASSIGN',
        '->':'ARROW','&&':'AND','||':'OR'};
      if(twoMap[twoChar]) {
        this.pos+=2; this.tokens.push(tok(twoMap[twoChar],twoChar)); continue;
      }
      const oneMap = {'+':'PLUS','-':'MINUS','*':'STAR','/':'SLASH','%':'PERCENT',
        '=':'ASSIGN','<':'LT','>':'GT','(':'LPAREN',')':'RPAREN','[':'LBRACKET',
        ']':'RBRACKET','{':'LBRACE','}':'RBRACE','.':'DOT',',':'COMMA',
        ':':'COLON',';':'SEMI','@':'AT','!':'BANG','&':'BITAND','|':'BITOR',
        '^':'BITXOR','~':'BITNOT'};
      if(oneMap[c]) { this.advance(); this.tokens.push(tok(oneMap[c],c)); continue; }
      this.advance(); // skip unknown
    }
    this.tokens.push({type:'EOF',value:'',line:this.line,col:this.col});
    return this.tokens;
  }
}

class Parser {
  constructor(tokens) {
    this.tokens = tokens.filter(t=>t.type!=='COMMENT');
    this.pos = 0;
  }
  peek(n=0) { return this.tokens[Math.min(this.pos+n, this.tokens.length-1)]; }
  advance() { const t = this.tokens[this.pos]; if(this.pos<this.tokens.length-1)this.pos++; return t; }
  check(t) { return this.peek().type===t; }
  eat(t) { if(!this.check(t)) throw new Error(`Expected ${t} got ${this.peek().type} at line ${this.peek().line}`); return this.advance(); }
  skipNewlines() { while(this.check('NEWLINE')) this.advance(); }

  parseProgram() {
    const stmts = []; this.skipNewlines();
    while(!this.check('EOF')) { stmts.push(this.parseStmt()); this.skipNewlines(); }
    return {type:'Program',body:stmts};
  }

  parseStmt() {
    this.skipNewlines();
    const t = this.peek();
    if(t.type==='VAR'||t.type==='CONST') return this.parseVarDecl();
    if(t.type==='FUNC') return this.parseFuncDecl();
    if(t.type==='IF') return this.parseIf();
    if(t.type==='FOR') return this.parseFor();
    if(t.type==='WHILE') return this.parseWhile();
    if(t.type==='RETURN') return this.parseReturn();
    if(t.type==='PASS') { this.advance(); return {type:'Pass'}; }
    if(t.type==='BREAK') { this.advance(); return {type:'Break'}; }
    if(t.type==='CONTINUE') { this.advance(); return {type:'Continue'}; }
    if(t.type==='SIGNAL') return this.parseSignal();
    if(t.type==='MATCH') return this.parseMatch();
    return this.parseExprStmt();
  }

  parseBlock() {
    const stmts = []; this.skipNewlines();
    this.eat('LBRACE');
    this.skipNewlines();
    while(!this.check('RBRACE')&&!this.check('EOF')) { stmts.push(this.parseStmt()); this.skipNewlines(); }
    this.eat('RBRACE');
    return {type:'Block',body:stmts};
  }

  parseVarDecl() {
    const kind = this.advance().type==='CONST'?'const':'var';
    const name = this.eat('IDENT').value;
    let init=null, typeAnnot=null;
    if(this.check('COLON')) { this.advance(); typeAnnot=this.eat('IDENT').value; }
    if(this.check('ASSIGN')) { this.advance(); init=this.parseExpr(); }
    return {type:'VarDecl',kind,name,typeAnnot,init};
  }

  parseFuncDecl() {
    this.eat('FUNC');
    const name = this.eat('IDENT').value;
    this.eat('LPAREN');
    const params = [];
    while(!this.check('RPAREN')&&!this.check('EOF')) {
      const pname = this.eat('IDENT').value;
      let def=null;
      if(this.check('ASSIGN')) { this.advance(); def=this.parseExpr(); }
      params.push({name:pname,default:def});
      if(this.check('COMMA')) this.advance();
    }
    this.eat('RPAREN');
    let retType=null;
    if(this.check('ARROW')) { this.advance(); retType=this.eat('IDENT').value; }
    this.skipNewlines();
    const body = this.parseBlock();
    return {type:'FuncDecl',name,params,retType,body};
  }

  parseIf() {
    this.eat('IF');
    const cond = this.parseExpr();
    this.skipNewlines();
    const then = this.parseBlock();
    const elifs = [];
    let els = null;
    while(true) {
      this.skipNewlines();
      if(this.check('ELIF')) {
        this.advance(); const c=this.parseExpr(); this.skipNewlines(); const b=this.parseBlock();
        elifs.push({cond:c,body:b});
      } else if(this.check('ELSE')) {
        this.advance(); this.skipNewlines(); els=this.parseBlock(); break;
      } else break;
    }
    return {type:'If',cond,then,elifs,else:els};
  }

  parseFor() {
    this.eat('FOR');
    const name = this.eat('IDENT').value;
    this.eat('IN');
    const iter = this.parseExpr();
    this.skipNewlines();
    const body = this.parseBlock();
    return {type:'For',name,iter,body};
  }

  parseWhile() {
    this.eat('WHILE');
    const cond = this.parseExpr();
    this.skipNewlines();
    const body = this.parseBlock();
    return {type:'While',cond,body};
  }

  parseReturn() {
    this.eat('RETURN');
    let val=null;
    if(!this.check('NEWLINE')&&!this.check('RBRACE')&&!this.check('EOF')) val=this.parseExpr();
    return {type:'Return',value:val};
  }

  parseSignal() {
    this.eat('SIGNAL');
    const name = this.eat('IDENT').value;
    return {type:'Signal',name};
  }

  parseMatch() {
    this.eat('MATCH');
    const val = this.parseExpr();
    this.skipNewlines();
    this.eat('LBRACE');
    const cases = [];
    this.skipNewlines();
    while(!this.check('RBRACE')&&!this.check('EOF')) {
      const pattern = this.parseExpr();
      this.eat('COLON');
      this.skipNewlines();
      const body = this.parseBlock();
      cases.push({pattern,body});
      this.skipNewlines();
    }
    this.eat('RBRACE');
    return {type:'Match',value:val,cases};
  }

  parseExprStmt() {
    const expr = this.parseExpr();
    return {type:'ExprStmt',expr};
  }

  parseExpr() { return this.parseAssign(); }

  parseAssign() {
    let left = this.parseOr();
    const assignOps = ['ASSIGN','PLUS_ASSIGN','MINUS_ASSIGN','MUL_ASSIGN','DIV_ASSIGN'];
    if(assignOps.includes(this.peek().type)) {
      const op = this.advance().type;
      const right = this.parseExpr();
      return {type:'Assign',op,left,right};
    }
    return left;
  }

  parseOr() {
    let left = this.parseAnd();
    while(this.check('OR')||this.peek().value==='or') { this.advance(); left={type:'Binary',op:'or',left,right:this.parseAnd()}; }
    return left;
  }
  parseAnd() {
    let left = this.parseNot();
    while(this.check('AND')||this.peek().value==='and') { this.advance(); left={type:'Binary',op:'and',left,right:this.parseNot()}; }
    return left;
  }
  parseNot() {
    if(this.check('NOT')||this.peek().value==='not'||this.check('BANG')) { this.advance(); return {type:'Unary',op:'not',operand:this.parseNot()}; }
    return this.parseCompare();
  }
  parseCompare() {
    let left = this.parseAdd();
    const ops = ['EQ','NEQ','LT','GT','LTE','GTE','IN','IS'];
    while(ops.includes(this.peek().type)) {
      const op=this.advance().value; left={type:'Binary',op,left,right:this.parseAdd()};
    }
    return left;
  }
  parseAdd() {
    let left = this.parseMul();
    while(this.check('PLUS')||this.check('MINUS')) { const op=this.advance().value; left={type:'Binary',op,left,right:this.parseMul()}; }
    return left;
  }
  parseMul() {
    let left = this.parseUnary();
    while(this.check('STAR')||this.check('SLASH')||this.check('PERCENT')) { const op=this.advance().value; left={type:'Binary',op,left,right:this.parseUnary()}; }
    return left;
  }
  parseUnary() {
    if(this.check('MINUS')) { this.advance(); return {type:'Unary',op:'-',operand:this.parseUnary()}; }
    return this.parsePower();
  }
  parsePower() {
    let left = this.parsePostfix();
    if(this.check('POWER')) { this.advance(); return {type:'Binary',op:'**',left,right:this.parseUnary()}; }
    return left;
  }
  parsePostfix() {
    let expr = this.parsePrimary();
    while(true) {
      if(this.check('DOT')) {
        this.advance(); const prop=this.eat('IDENT').value;
        if(this.check('LPAREN')) {
          this.advance();
          const args = this.parseArgList();
          this.eat('RPAREN');
          expr = {type:'MethodCall',object:expr,method:prop,args};
        } else {
          expr = {type:'MemberExpr',object:expr,property:prop};
        }
      } else if(this.check('LBRACKET')) {
        this.advance(); const idx=this.parseExpr(); this.eat('RBRACKET');
        expr = {type:'Index',object:expr,index:idx};
      } else break;
    }
    return expr;
  }
  parsePrimary() {
    const t = this.peek();
    if(t.type==='NUMBER') { this.advance(); return {type:'Literal',value:t.value,vtype:'number'}; }
    if(t.type==='STRING') { this.advance(); return {type:'Literal',value:t.value,vtype:'string'}; }
    if(t.type==='TRUE') { this.advance(); return {type:'Literal',value:true,vtype:'bool'}; }
    if(t.type==='FALSE') { this.advance(); return {type:'Literal',value:false,vtype:'bool'}; }
    if(t.type==='NULL') { this.advance(); return {type:'Literal',value:null,vtype:'null'}; }
    if(t.type==='SELF') { this.advance(); return {type:'Self'}; }
    if(t.type==='LPAREN') {
      this.advance(); const e=this.parseExpr(); this.eat('RPAREN'); return e;
    }
    if(t.type==='LBRACKET') {
      this.advance(); const els=[];
      while(!this.check('RBRACKET')&&!this.check('EOF')) { els.push(this.parseExpr()); if(this.check('COMMA'))this.advance(); }
      this.eat('RBRACKET'); return {type:'ArrayLit',elements:els};
    }
    if(t.type==='LBRACE') {
      this.advance(); const pairs=[];
      while(!this.check('RBRACE')&&!this.check('EOF')) {
        const k=this.parseExpr(); this.eat('COLON'); const v=this.parseExpr();
        pairs.push({key:k,value:v}); if(this.check('COMMA'))this.advance();
      }
      this.eat('RBRACE'); return {type:'DictLit',pairs};
    }
    if(t.type==='IDENT') {
      this.advance();
      if(this.check('LPAREN')) {
        this.advance(); const args=this.parseArgList(); this.eat('RPAREN');
        return {type:'Call',name:t.value,args};
      }
      return {type:'Identifier',name:t.value};
    }
    this.advance();
    return {type:'Literal',value:null};
  }
  parseArgList() {
    const args=[];
    while(!this.check('RPAREN')&&!this.check('EOF')) {
      args.push(this.parseExpr()); if(this.check('COMMA'))this.advance();
    }
    return args;
  }
}

// ============================================================
//   MATH TYPES
// ============================================================

class Vec2 {
  constructor(x=0,y=0) { this.x=x; this.y=y; }
  add(v) { return new Vec2(this.x+v.x, this.y+v.y); }
  sub(v) { return new Vec2(this.x-v.x, this.y-v.y); }
  mul(s) { return typeof s==='number' ? new Vec2(this.x*s,this.y*s) : new Vec2(this.x*s.x,this.y*s.y); }
  div(s) { return typeof s==='number' ? new Vec2(this.x/s,this.y/s) : new Vec2(this.x/s.x,this.y/s.y); }
  dot(v) { return this.x*v.x + this.y*v.y; }
  cross(v) { return this.x*v.y - this.y*v.x; }
  len() { return Math.sqrt(this.x*this.x+this.y*this.y); }
  lenSq() { return this.x*this.x+this.y*this.y; }
  norm() { const l=this.len(); return l>0 ? this.div(l) : new Vec2(); }
  angle() { return Math.atan2(this.y,this.x); }
  rotate(a) { const c=Math.cos(a),s=Math.sin(a); return new Vec2(this.x*c-this.y*s,this.x*s+this.y*c); }
  lerp(v,t) { return new Vec2(this.x+(v.x-this.x)*t, this.y+(v.y-this.y)*t); }
  clone() { return new Vec2(this.x,this.y); }
  toString() { return `Vector2(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`; }
  static fromAngle(a,l=1) { return new Vec2(Math.cos(a)*l, Math.sin(a)*l); }
  static zero() { return new Vec2(0,0); }
  static up() { return new Vec2(0,-1); }
  static down() { return new Vec2(0,1); }
  static left() { return new Vec2(-1,0); }
  static right() { return new Vec2(1,0); }
}

class NColor {
  constructor(r=1,g=1,b=1,a=1) { this.r=r; this.g=g; this.b=b; this.a=a; }
  toCSS() { return `rgba(${(this.r*255)|0},${(this.g*255)|0},${(this.b*255)|0},${this.a})`; }
  toHex() {
    const h = v => Math.min(255,Math.max(0,(v*255)|0)).toString(16).padStart(2,'0');
    return `#${h(this.r)}${h(this.g)}${h(this.b)}`;
  }
  lerp(c,t) { return new NColor(this.r+(c.r-this.r)*t,this.g+(c.g-this.g)*t,this.b+(c.b-this.b)*t,this.a+(c.a-this.a)*t); }
  static fromHex(h) {
    h = h.replace('#','');
    return new NColor(parseInt(h.slice(0,2),16)/255,parseInt(h.slice(2,4),16)/255,parseInt(h.slice(4,6),16)/255,1);
  }
  static white() { return new NColor(1,1,1,1); }
  static black() { return new NColor(0,0,0,1); }
  static red() { return new NColor(1,0,0,1); }
  static green() { return new NColor(0,1,0,1); }
  static blue() { return new NColor(0,0,1,1); }
}

// ============================================================
//   INTERPRETER
// ============================================================

class Environment {
  constructor(parent=null) { this.vars={}; this.parent=parent; }
  get(name) {
    if(name in this.vars) return this.vars[name];
    if(this.parent) return this.parent.get(name);
    return undefined;
  }
  set(name,value) {
    if(name in this.vars) { this.vars[name]=value; return; }
    if(this.parent && this.parent.has(name)) { this.parent.set(name,value); return; }
    this.vars[name]=value;
  }
  def(name,value) { this.vars[name]=value; }
  has(name) { return name in this.vars || (this.parent&&this.parent.has(name)); }
}

class ReturnSignal { constructor(v){this.value=v;} }
class BreakSignal {}
class ContinueSignal {}

class Interpreter {
  constructor(node, engine) {
    this.nodeObj = node; // The scene node this script runs on
    this.engine = engine;
    this.globals = new Environment();
    this.setupBuiltins();
  }
  setupBuiltins() {
    const g = this.globals;
    // Math
    g.def('sin', a=>Math.sin(a)); g.def('cos', a=>Math.cos(a));
    g.def('tan', a=>Math.tan(a)); g.def('sqrt', a=>Math.sqrt(a));
    g.def('abs', a=>Math.abs(a)); g.def('floor', a=>Math.floor(a));
    g.def('ceil', a=>Math.ceil(a)); g.def('round', a=>Math.round(a));
    g.def('min', (a,b)=>Math.min(a,b)); g.def('max', (a,b)=>Math.max(a,b));
    g.def('clamp', (v,lo,hi)=>Math.max(lo,Math.min(hi,v)));
    g.def('lerp', (a,b,t)=>a+(b-a)*t); g.def('sign', a=>Math.sign(a));
    g.def('pow', (a,b)=>Math.pow(a,b)); g.def('log', a=>Math.log(a));
    g.def('exp', a=>Math.exp(a));
    g.def('rand', ()=>Math.random());
    g.def('randi', (lo=0,hi=100)=>Math.floor(Math.random()*(hi-lo))+lo);
    g.def('randf', (lo=0,hi=1)=>Math.random()*(hi-lo)+lo);
    g.def('deg2rad', a=>a*Math.PI/180); g.def('rad2deg', a=>a*180/Math.PI);
    g.def('PI', Math.PI); g.def('TAU', Math.PI*2); g.def('INF', Infinity);
    g.def('NAN', NaN);
    // Constructors
    g.def('Vector2', (x=0,y=0)=>new Vec2(x,y));
    g.def('Color', (r=1,g2=1,b=1,a=1)=>new NColor(r,g2,b,a));
    // Print
    g.def('print', (...args)=>{ this.engine.console_log(args.map(a=>this.toStr(a)).join(' ')); });
    g.def('print_err', (...args)=>{ this.engine.console_error(args.map(a=>this.toStr(a)).join(' ')); });
    g.def('str', a=>this.toStr(a)); g.def('int', a=>a|0); g.def('float', a=>+a);
    g.def('bool', a=>!!a); g.def('len', a=>a?.length??0);
    g.def('range', (a,b,c)=>{
      const arr=[]; let s=c||1,lo=b===undefined?0:a, hi=b===undefined?a:b;
      for(let i=lo;i<hi;i+=s)arr.push(i); return arr;
    });
    g.def('typeof', a=>{
      if(a instanceof Vec2) return 'Vector2';
      if(a instanceof NColor) return 'Color';
      if(Array.isArray(a)) return 'Array';
      return typeof a;
    });
    // Input
    g.def('Input', {
      key: (k) => this.engine.input.keys.has(k),
      key_pressed: (k) => this.engine.input.pressed.has(k),
      key_released: (k) => this.engine.input.released.has(k),
      mouse_pos: () => this.engine.input.mousePos.clone(),
      mouse_button: (b=0) => this.engine.input.mouseButtons[b]||false,
      get_axis: (neg,pos) => (this.engine.input.keys.has(pos)?1:0)-(this.engine.input.keys.has(neg)?1:0),
    });
    // self/node ref
    if(this.nodeObj) {
      g.def('self', this.nodeObj);
      g.def('position', this.nodeObj.position || new Vec2());
      g.def('rotation', this.nodeObj.rotation || 0);
      g.def('scale', this.nodeObj.scale || new Vec2(1,1));
    }
    g.def('get_node', (path) => this.engine.findNode(path));
    g.def('get_tree', () => this.engine.sceneTree);
    g.def('delta', 0.016);
    g.def('time', 0);
  }
  eval(ast, env=null) {
    if(!env) env = this.globals;
    if(!ast) return null;
    try { return this._eval(ast, env); } catch(e) {
      if(e instanceof ReturnSignal) return e.value;
      if(e instanceof BreakSignal || e instanceof ContinueSignal) return null;
      throw e;
    }
  }
  _eval(node, env) {
    switch(node.type) {
      case 'Program': { let r=null; for(const s of node.body) r=this._eval(s,env); return r; }
      case 'Block': { let r=null; for(const s of node.body) { r=this._eval(s,env); if(r instanceof ReturnSignal||r instanceof BreakSignal||r instanceof ContinueSignal)return r; } return r; }
      case 'Literal': return node.value;
      case 'Identifier': return env.get(node.name);
      case 'Self': return this.nodeObj;
      case 'ArrayLit': return node.elements.map(e=>this._eval(e,env));
      case 'DictLit': { const d={}; for(const p of node.pairs) d[this._eval(p.key,env)]=this._eval(p.value,env); return d; }
      case 'Unary': {
        const v=this._eval(node.operand,env);
        if(node.op==='-') return v instanceof Vec2 ? v.mul(-1) : -v;
        if(node.op==='not'||node.op==='!') return !v;
        return v;
      }
      case 'Binary': return this.evalBinary(node, env);
      case 'Assign': return this.evalAssign(node, env);
      case 'VarDecl': {
        const val = node.init ? this._eval(node.init,env) : null;
        env.def(node.name, val); return val;
      }
      case 'FuncDecl': {
        const fn = (...args) => {
          const fenv = new Environment(env);
          node.params.forEach((p,i)=>fenv.def(p.name, args[i]!==undefined?args[i]:(p.default?this._eval(p.default,env):null)));
          const r = this._eval(node.body, fenv);
          if(r instanceof ReturnSignal) return r.value;
          return null;
        };
        fn._name = node.name;
        env.def(node.name, fn);
        return fn;
      }
      case 'Call': {
        const fn = env.get(node.name);
        if(typeof fn !== 'function') throw new Error(`'${node.name}' is not a function`);
        const args = node.args.map(a=>this._eval(a,env));
        return fn(...args);
      }
      case 'MethodCall': {
        const obj = this._eval(node.object, env);
        if(obj===null||obj===undefined) throw new Error(`Cannot call method '${node.method}' on null`);
        const method = obj[node.method];
        const args = node.args.map(a=>this._eval(a,env));
        if(typeof method === 'function') return method.call(obj, ...args);
        throw new Error(`'${node.method}' is not a method`);
      }
      case 'MemberExpr': {
        const obj = this._eval(node.object, env);
        if(obj===null||obj===undefined) return undefined;
        return obj[node.property];
      }
      case 'Index': {
        const obj=this._eval(node.object,env), idx=this._eval(node.index,env);
        return obj?.[idx];
      }
      case 'If': {
        if(this._eval(node.cond,env)) return this._eval(node.then,env);
        for(const el of node.elifs) if(this._eval(el.cond,env)) return this._eval(el.body,env);
        if(node.else) return this._eval(node.else,env);
        return null;
      }
      case 'For': {
        const iter = this._eval(node.iter, env);
        if(!iter||!iter[Symbol.iterator]) return null;
        for(const item of iter) {
          const lenv = new Environment(env); lenv.def(node.name, item);
          const r = this._eval(node.body, lenv);
          if(r instanceof BreakSignal) break;
          if(r instanceof ReturnSignal) return r;
        }
        return null;
      }
      case 'While': {
        let safe=0;
        while(this._eval(node.cond,env) && safe++<100000) {
          const r = this._eval(node.body, new Environment(env));
          if(r instanceof BreakSignal) break;
          if(r instanceof ReturnSignal) return r;
        }
        return null;
      }
      case 'Return': return new ReturnSignal(node.value ? this._eval(node.value,env) : null);
      case 'Break': return new BreakSignal();
      case 'Continue': return new ContinueSignal();
      case 'Pass': return null;
      case 'Signal': env.def(node.name, {_isSignal:true,name:node.name,listeners:[],connect:(fn)=>{}});  return null;
      case 'ExprStmt': return this._eval(node.expr, env);
      case 'Match': {
        const val = this._eval(node.value, env);
        for(const c of node.cases) {
          const pat = this._eval(c.pattern, env);
          if(pat==='_'||val===pat||JSON.stringify(val)===JSON.stringify(pat)) {
            return this._eval(c.body, env);
          }
        }
        return null;
      }
      default: return null;
    }
  }
  evalBinary(node, env) {
    const l=this._eval(node.left,env), r=this._eval(node.right,env);
    const op = node.op;
    if(l instanceof Vec2 && r instanceof Vec2) {
      if(op==='+')return l.add(r); if(op==='-')return l.sub(r);
      if(op==='*')return l.mul(r); if(op==='/')return l.div(r);
      if(op==='==')return Math.abs(l.x-r.x)<1e-6&&Math.abs(l.y-r.y)<1e-6;
    }
    if(l instanceof Vec2 && typeof r==='number') {
      if(op==='*')return l.mul(r); if(op==='/')return l.div(r);
    }
    switch(op) {
      case '+': return l+r; case '-': return l-r; case '*': return l*r;
      case '/': return r!==0?l/r:0; case '%': return l%r; case '**': return Math.pow(l,r);
      case '==': return l===r; case '!=': return l!==r;
      case '<': return l<r; case '>': return l>r; case '<=': return l<=r; case '>=': return l>=r;
      case 'and': case '&&': return l&&r;
      case 'or': case '||': return l||r;
      case 'in': return Array.isArray(r)?r.includes(l):(typeof r==='object'&&r!==null)?l in r:false;
    }
    return null;
  }
  evalAssign(node, env) {
    const val = this._eval(node.right, env);
    const op = node.op;
    if(node.left.type==='Identifier') {
      const name = node.left.name;
      const cur = env.get(name);
      let newVal = val;
      if(op==='+=') newVal = cur instanceof Vec2 ? cur.add(val) : cur+val;
      if(op==='-=') newVal = cur instanceof Vec2 ? cur.sub(val) : cur-val;
      if(op==='*=') newVal = cur instanceof Vec2 ? cur.mul(val) : cur*val;
      if(op==='/=') newVal = cur/val;
      env.set(name, newVal);
      // Sync node properties
      if(this.nodeObj) {
        if(name==='position')this.nodeObj.position=newVal;
        if(name==='rotation')this.nodeObj.rotation=newVal;
        if(name==='scale')this.nodeObj.scale=newVal;
        if(name==='visible')this.nodeObj.visible=newVal;
      }
      return newVal;
    }
    if(node.left.type==='MemberExpr') {
      const obj = this._eval(node.left.object, env);
      const cur = obj[node.left.property];
      let newVal = val;
      if(op==='+=') newVal = cur instanceof Vec2 ? cur.add(val) : cur+val;
      if(op==='-=') newVal = cur instanceof Vec2 ? cur.sub(val) : cur-val;
      obj[node.left.property] = newVal;
      return newVal;
    }
    return val;
  }
  toStr(v) {
    if(v===null||v===undefined) return 'null';
    if(v instanceof Vec2) return v.toString();
    if(v instanceof NColor) return `Color(${v.r.toFixed(2)},${v.g.toFixed(2)},${v.b.toFixed(2)})`;
    if(Array.isArray(v)) return '['+v.map(x=>this.toStr(x)).join(', ')+']';
    if(typeof v==='object') return JSON.stringify(v);
    return String(v);
  }
}

// ============================================================
//   SCENE NODES
// ============================================================

let nodeIdCounter = 1;

class SceneNode {
  constructor(type, name) {
    this.id = nodeIdCounter++;
    this.type = type;
    this.name = name || type + nodeIdCounter;
    this.children = [];
    this.parent = null;
    this.visible = true;
    this.position = new Vec2(0,0);
    this.rotation = 0;
    this.scale = new Vec2(1,1);
    this.script = null;
    this.interpreter = null;
    this.signals = {};
    this.groups = [];
    this._transform = {x:0,y:0,r:0,sx:1,sy:1};
    this._worldPos = new Vec2(0,0);
    this.metadata = {};
    this.zIndex = 0;
  }
  getWorldTransform() {
    if(!this.parent || this.parent.type==='Root') return {x:this.position.x,y:this.position.y,r:this.rotation,sx:this.scale.x,sy:this.scale.y};
    const pt = this.parent.getWorldTransform();
    return {x:pt.x+this.position.x,y:pt.y+this.position.y,r:pt.r+this.rotation,sx:pt.sx*this.scale.x,sy:pt.sy*this.scale.y};
  }
  addChild(child) { child.parent=this; this.children.push(child); return child; }
  removeChild(child) {
    const i=this.children.indexOf(child);
    if(i>=0){this.children.splice(i,1); child.parent=null;}
  }
  findChild(name) {
    if(this.name===name) return this;
    for(const c of this.children){const f=c.findChild(name);if(f)return f;}
    return null;
  }
  callScript(fn, ...args) {
    if(this.interpreter && this.interpreter.globals.has(fn)) {
      try {
        const f = this.interpreter.globals.get(fn);
        if(typeof f==='function') return f(...args);
      } catch(e) { engine.console_error(`[${this.name}] ${e.message}`); }
    }
  }
  serialize() {
    return {type:this.type,name:this.name,position:{x:this.position.x,y:this.position.y},
      rotation:this.rotation,scale:{x:this.scale.x,y:this.scale.y},visible:this.visible,
      script:this.script, children:this.children.map(c=>c.serialize()),
      zIndex:this.zIndex,...this.getExtraProps()};
  }
  getExtraProps(){return{};}
}

class Node2D extends SceneNode {
  constructor(name) { super('Node2D',name); }
  getExtraProps(){return{};}
}

class Sprite2D extends SceneNode {
  constructor(name) {
    super('Sprite2D',name);
    this.texture = null;
    this.color = new NColor(1,1,1,1);
    this.width = 64; this.height = 64;
    this.flipX = false; this.flipY = false;
    this.centered = true;
    this.shape = 'rect'; // rect, circle, triangle, sprite
    this.frame = 0;
    this.hframes = 1; this.vframes = 1;
  }
  getExtraProps(){return{color:this.color,width:this.width,height:this.height,shape:this.shape};}
}

class RigidBody2D extends SceneNode {
  constructor(name) {
    super('RigidBody2D',name);
    this.velocity = new Vec2(0,0);
    this.angularVelocity = 0;
    this.mass = 1;
    this.restitution = 0.3;
    this.friction = 0.5;
    this.linearDamping = 0.02;
    this.angularDamping = 0.05;
    this.gravityScale = 1;
    this.fixedRotation = false;
    this.bodyType = 'dynamic';
    this.collider = {type:'rect',width:64,height:64};
    this.color = new NColor(0.4,0.6,1,1);
    this.width = 64; this.height = 64;
    this.onFloor = false;
  }
}

class StaticBody2D extends SceneNode {
  constructor(name) {
    super('StaticBody2D',name);
    this.collider = {type:'rect',width:200,height:32};
    this.color = new NColor(0.5,0.5,0.5,1);
    this.width = 200; this.height = 32;
  }
}

class KinematicBody2D extends SceneNode {
  constructor(name) {
    super('KinematicBody2D',name);
    this.velocity = new Vec2(0,0);
    this.collider = {type:'rect',width:32,height:64};
    this.color = new NColor(0.3,1,0.5,1);
    this.width = 32; this.height = 64;
    this.onFloor = false;
    this.onWall = false;
    this.onCeiling = false;
  }
}

class Area2D extends SceneNode {
  constructor(name) {
    super('Area2D',name);
    this.collider = {type:'rect',width:64,height:64};
    this.color = new NColor(1,0.8,0,0.3);
    this.width = 64; this.height = 64;
    this.monitoring = true;
    this.monitorable = true;
    this.overlapping = [];
  }
}

class Camera2D extends SceneNode {
  constructor(name) {
    super('Camera2D',name);
    this.zoom = new Vec2(1,1);
    this.current = true;
    this.offset = new Vec2(0,0);
    this.smoothing = 0.1;
    this.limits = {left:-99999,top:-99999,right:99999,bottom:99999};
  }
}

class Light2D extends SceneNode {
  constructor(name) {
    super('Light2D',name);
    this.color = new NColor(1,0.9,0.7,1);
    this.energy = 1;
    this.range = 200;
    this.enabled = true;
    this.mode = 'add';
  }
}

class TileMap extends SceneNode {
  constructor(name) {
    super('TileMap',name);
    this.tileSize = 32;
    this.tiles = {};
    this.width = 400; this.height = 400;
  }
}

class ParticleEmitter2D extends SceneNode {
  constructor(name) {
    super('ParticleEmitter2D',name);
    this.amount = 50;
    this.lifetime = 2;
    this.speed = 100;
    this.spread = Math.PI;
    this.gravity = new Vec2(0,200);
    this.color = new NColor(1,0.5,0,1);
    this.colorEnd = new NColor(1,0,0,0);
    this.emitting = true;
    this.particles = [];
    this._timer = 0;
  }
  initParticles() {
    this.particles = [];
    for(let i=0;i<this.amount;i++) {
      this.particles.push({x:0,y:0,vx:0,vy:0,t:Math.random()*this.lifetime,life:this.lifetime,size:4,active:false});
    }
  }
}

class Label extends SceneNode {
  constructor(name) {
    super('Label',name);
    this.text = 'Label';
    this.fontSize = 16;
    this.color = new NColor(1,1,1,1);
    this.fontFamily = 'JetBrains Mono';
    this.align = 'left';
    this.outline = false;
  }
}

class AudioStreamPlayer extends SceneNode {
  constructor(name) {
    super('AudioStreamPlayer',name);
    this.stream = null;
    this.volume = 1;
    this.pitch = 1;
    this.looping = false;
    this.autoplay = false;
    this.playing = false;
  }
}

class Timer extends SceneNode {
  constructor(name) {
    super('Timer',name);
    this.waitTime = 1;
    this.autostart = false;
    this.oneShot = false;
    this.paused = false;
    this._time = 0;
    this.running = false;
  }
}

class Tween extends SceneNode {
  constructor(name) {
    super('Tween',name);
    this.tweens = [];
    this.running = false;
  }
}

class AnimationPlayer extends SceneNode {
  constructor(name) {
    super('AnimationPlayer',name);
    this.animations = {};
    this.currentAnim = null;
    this.playing = false;
    this.speed = 1;
    this._time = 0;
  }
}

class CollisionShape2D extends SceneNode {
  constructor(name) {
    super('CollisionShape2D',name);
    this.shape = 'rect';
    this.width = 64; this.height = 64;
    this.radius = 32;
    this.disabled = false;
  }
}

class Path2D extends SceneNode {
  constructor(name) {
    super('Path2D',name);
    this.points = [new Vec2(-100,0),new Vec2(0,-50),new Vec2(100,0)];
    this.closed = false;
    this.color = new NColor(0,1,1,0.7);
  }
}

class RayCast2D extends SceneNode {
  constructor(name) {
    super('RayCast2D',name);
    this.targetPosition = new Vec2(0,100);
    this.enabled = true;
    this.collideWith = ['bodies','areas'];
    this.hit = false;
    this.hitPoint = null;
    this.hitNormal = null;
  }
}

class CanvasLayer extends SceneNode {
  constructor(name) {
    super('CanvasLayer',name);
    this.layer = 1;
  }
}

class ColorRect extends SceneNode {
  constructor(name) {
    super('ColorRect',name);
    this.color = new NColor(0.2,0.2,0.8,1);
    this.width = 100; this.height = 100;
  }
}

const NODE_TYPES = {
  'Node2D': {cls:Node2D, icon:'‚¨°', color:'#60a5fa', desc:'Base 2D node', category:'Core'},
  'Sprite2D': {cls:Sprite2D, icon:'üñº', color:'#a3e635', desc:'Displays a texture or shape', category:'2D'},
  'RigidBody2D': {cls:RigidBody2D, icon:'‚¨§', color:'#f97316', desc:'Physics-simulated body', category:'Physics'},
  'StaticBody2D': {cls:StaticBody2D, icon:'‚ñ¨', color:'#94a3b8', desc:'Non-moving physics body', category:'Physics'},
  'KinematicBody2D': {cls:KinematicBody2D, icon:'‚ñ≤', color:'#22d67a', desc:'Player-controlled body', category:'Physics'},
  'Area2D': {cls:Area2D, icon:'‚ó´', color:'#fbbf24', desc:'Detection/trigger zone', category:'Physics'},
  'Camera2D': {cls:Camera2D, icon:'üì∑', color:'#c792ea', desc:'2D camera viewport', category:'Rendering'},
  'Light2D': {cls:Light2D, icon:'üí°', color:'#fde68a', desc:'2D dynamic light', category:'Rendering'},
  'Label': {cls:Label, icon:'T', color:'#f0f0f0', desc:'Display text', category:'UI'},
  'ColorRect': {cls:ColorRect, icon:'‚ñß', color:'#818cf8', desc:'Colored rectangle', category:'UI'},
  'AnimationPlayer': {cls:AnimationPlayer, icon:'‚ñ∂', color:'#34d399', desc:'Play animations', category:'Animation'},
  'Timer': {cls:Timer, icon:'‚è±', color:'#60a5fa', desc:'Countdown timer', category:'Utility'},
  'Tween': {cls:Tween, icon:'„Ä∞', color:'#e879f9', desc:'Property interpolation', category:'Utility'},
  'ParticleEmitter2D': {cls:ParticleEmitter2D, icon:'‚ú¶', color:'#fb923c', desc:'Particle effects', category:'Effects'},
  'TileMap': {cls:TileMap, icon:'‚äû', color:'#4ade80', desc:'Tile-based level', category:'2D'},
  'AudioStreamPlayer': {cls:AudioStreamPlayer, icon:'‚ô™', color:'#22d3ee', desc:'Audio playback', category:'Audio'},
  'Path2D': {cls:Path2D, icon:'„Ä∞', color:'#00d4ff', desc:'Spline path', category:'2D'},
  'RayCast2D': {cls:RayCast2D, icon:'‚Üó', color:'#f87171', desc:'Raycast collision', category:'Physics'},
  'CollisionShape2D': {cls:CollisionShape2D, icon:'‚ä°', color:'#94a3b8', desc:'Collision boundary', category:'Physics'},
  'CanvasLayer': {cls:CanvasLayer, icon:'‚ßâ', color:'#a78bfa', desc:'UI layer', category:'UI'},
};

// ============================================================
//   PHYSICS ENGINE
// ============================================================

class Physics {
  constructor(engine) {
    this.engine = engine;
    this.gravity = new Vec2(0, 980);
    this.enabled = true;
    this.debug = false;
    this.iterations = 8;
    this.bodies = [];
    this.statics = [];
  }

  update(dt, nodes) {
    if(!this.enabled) return;
    this.bodies = [];
    this.statics = [];
    this._collectBodies(nodes);

    // Integrate velocity
    for(const b of this.bodies) {
      if(b.bodyType === 'static') continue;
      b.velocity.y += this.gravity.y * b.gravityScale * dt;
      b.velocity.x += this.gravity.x * b.gravityScale * dt;
      b.velocity.x *= (1 - b.linearDamping);
      b.velocity.y *= (1 - b.linearDamping * 0.5);
      b.position.x += b.velocity.x * dt;
      b.position.y += b.velocity.y * dt;
      if(!b.fixedRotation) {
        b.rotation += b.angularVelocity * dt;
        b.angularVelocity *= (1 - b.angularDamping);
      }
      b.onFloor = false;
    }

    // Collision detection & resolution
    for(let iter=0;iter<this.iterations;iter++) {
      for(const body of this.bodies) {
        for(const stat of this.statics) {
          this._resolveBodyStatic(body, stat);
        }
        for(const other of this.bodies) {
          if(body===other) continue;
          this._resolveBodyBody(body, other);
        }
      }
    }

    // Kinematics
    for(const k of this._collectKinematics(nodes)) {
      k.onFloor = false; k.onWall = false; k.onCeiling = false;
      k.position.x += k.velocity.x * dt;
      k.position.y += k.velocity.y * dt;
      for(const stat of this.statics) {
        this._resolveKinematicStatic(k, stat);
      }
    }
  }

  _collectBodies(nodes) {
    for(const node of nodes) {
      if(node.type==='RigidBody2D') this.bodies.push(node);
      else if(node.type==='StaticBody2D'||node.type==='TileMap') this.statics.push(node);
      if(node.children.length) this._collectBodies(node.children);
    }
  }
  _collectKinematics(nodes) {
    let ks=[];
    for(const node of nodes) {
      if(node.type==='KinematicBody2D') ks.push(node);
      if(node.children.length) ks.push(...this._collectKinematics(node.children));
    }
    return ks;
  }

  _getAABB(node) {
    const w = node.width||64, h = node.height||64;
    return {x:node.position.x - w/2, y:node.position.y - h/2, w, h,
            cx:node.position.x, cy:node.position.y};
  }

  _resolveBodyStatic(body, stat) {
    const a = this._getAABB(body), b = this._getAABB(stat);
    const ox = (a.cx-b.cx), oy = (a.cy-b.cy);
    const hw = (a.w+b.w)/2, hh = (a.h+b.h)/2;
    if(Math.abs(ox) >= hw || Math.abs(oy) >= hh) return;
    const px = hw - Math.abs(ox), py = hh - Math.abs(oy);
    if(px < py) {
      body.position.x += (ox>0?px:-px);
      body.velocity.x *= -body.restitution;
    } else {
      body.position.y += (oy>0?py:-py);
      if(oy>0) { body.onFloor=true; if(body.velocity.y<0) body.velocity.y*=-body.restitution; }
      else { body.velocity.y *= -body.restitution; }
      body.velocity.x *= (1-body.friction);
    }
  }

  _resolveBodyBody(a, b) {
    const aa = this._getAABB(a), bb = this._getAABB(b);
    const ox = aa.cx-bb.cx, oy = aa.cy-bb.cy;
    const hw = (aa.w+bb.w)/2, hh = (aa.h+bb.h)/2;
    if(Math.abs(ox)>=hw||Math.abs(oy)>=hh) return;
    const px = hw-Math.abs(ox), py = hh-Math.abs(oy);
    const massA = a.mass, massB = b.mass, total = massA+massB;
    if(px<py) {
      const push = (ox>0?px:-px)/2;
      a.position.x += push; b.position.x -= push;
      const relVx = a.velocity.x - b.velocity.x;
      const imp = relVx * Math.min(a.restitution, b.restitution);
      a.velocity.x -= imp*(massB/total); b.velocity.x += imp*(massB/total);
    } else {
      const push = (oy>0?py:-py)/2;
      a.position.y += push; b.position.y -= push;
      const relVy = a.velocity.y - b.velocity.y;
      const imp = relVy * Math.min(a.restitution, b.restitution);
      a.velocity.y -= imp*(massB/total); b.velocity.y += imp*(massB/total);
    }
  }

  _resolveKinematicStatic(k, stat) {
    const a = this._getAABB(k), b = this._getAABB(stat);
    const ox = a.cx-b.cx, oy = a.cy-b.cy;
    const hw = (a.w+b.w)/2, hh = (a.h+b.h)/2;
    if(Math.abs(ox)>=hw||Math.abs(oy)>=hh) return;
    const px = hw-Math.abs(ox), py = hh-Math.abs(oy);
    if(px<py) {
      k.position.x += (ox>0?px:-px); k.onWall=true;
      k.velocity.x = 0;
    } else {
      k.position.y += (oy>0?py:-py);
      if(oy>0){k.onFloor=true; if(k.velocity.y<0)k.velocity.y=0;}
      else {k.onCeiling=true; if(k.velocity.y>0)k.velocity.y=0;}
    }
  }
}

// ============================================================
//   INPUT SYSTEM
// ============================================================

class Input {
  constructor() {
    this.keys = new Set();
    this.pressed = new Set();
    this.released = new Set();
    this.mousePos = new Vec2(0,0);
    this.mouseButtons = [false,false,false];
    this._setupListeners();
  }
  _setupListeners() {
    window.addEventListener('keydown',e=>{
      if(!this.keys.has(e.key)) this.pressed.add(e.key);
      this.keys.add(e.key);
    });
    window.addEventListener('keyup',e=>{
      this.keys.delete(e.key);
      this.released.add(e.key);
    });
  }
  tick() {
    this.pressed.clear();
    this.released.clear();
  }
}

// ============================================================
//   RENDERER
// ============================================================

class Renderer {
  constructor(canvas, glCanvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.glCanvas = glCanvas;
    this.gl = null;
    this.cameraX = 0; this.cameraY = 0;
    this.cameraZoom = 1;
    this.showGrid = true;
    this.showPhysicsDebug = false;
    this.shaders = new Map();
    this.time = 0;
  }

  resize(w, h) {
    this.canvas.width = w; this.canvas.height = h;
    if(this.glCanvas) { this.glCanvas.width=w; this.glCanvas.height=h; }
  }

  worldToScreen(wx, wy) {
    return {
      x: (wx - this.cameraX) * this.cameraZoom + this.canvas.width/2,
      y: (wy - this.cameraY) * this.cameraZoom + this.canvas.height/2
    };
  }

  screenToWorld(sx, sy) {
    return new Vec2(
      (sx - this.canvas.width/2) / this.cameraZoom + this.cameraX,
      (sy - this.canvas.height/2) / this.cameraZoom + this.cameraY
    );
  }

  clear(bgColor='#0f1015') {
    const ctx = this.ctx;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = bgColor;
    ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
  }

  drawGrid() {
    if(!this.showGrid) return;
    const ctx = this.ctx;
    const W = this.canvas.width, H = this.canvas.height;
    const gridSize = 32 * this.cameraZoom;
    const ox = (-this.cameraX * this.cameraZoom + W/2) % gridSize;
    const oy = (-this.cameraY * this.cameraZoom + H/2) % gridSize;
    ctx.strokeStyle = 'rgba(40,45,60,0.8)';
    ctx.lineWidth = 1;
    for(let x=ox; x<W; x+=gridSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=oy; y<H; y+=gridSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    // Axes
    const ox2 = -this.cameraX * this.cameraZoom + W/2;
    const oy2 = -this.cameraY * this.cameraZoom + H/2;
    ctx.strokeStyle = 'rgba(244,63,94,0.4)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0,oy2); ctx.lineTo(W,oy2); ctx.stroke();
    ctx.strokeStyle = 'rgba(34,214,122,0.4)';
    ctx.beginPath(); ctx.moveTo(ox2,0); ctx.lineTo(ox2,H); ctx.stroke();
  }

  applyCamera(ctx) {
    ctx.setTransform(this.cameraZoom, 0, 0, this.cameraZoom,
      this.canvas.width/2 - this.cameraX * this.cameraZoom,
      this.canvas.height/2 - this.cameraY * this.cameraZoom);
  }

  renderScene(nodes, selectedId, isRunning) {
    const ctx = this.ctx;
    this.drawGrid();
    this.applyCamera(ctx);

    const sorted = [...nodes].sort((a,b)=>(a.zIndex||0)-(b.zIndex||0));
    for(const node of sorted) this.renderNode(node, selectedId, isRunning);

    ctx.setTransform(1,0,0,1,0,0);
  }

  renderNode(node, selectedId, isRunning) {
    if(!node.visible) return;
    const ctx = this.ctx;
    const wt = node.getWorldTransform();

    ctx.save();
    ctx.translate(wt.x, wt.y);
    ctx.rotate(wt.r);
    ctx.scale(wt.sx, wt.sy);

    switch(node.type) {
      case 'Sprite2D': this.drawSprite(node, ctx); break;
      case 'RigidBody2D': this.drawRigidBody(node, ctx); break;
      case 'StaticBody2D': this.drawStaticBody(node, ctx); break;
      case 'KinematicBody2D': this.drawKinematic(node, ctx); break;
      case 'Area2D': this.drawArea(node, ctx); break;
      case 'Light2D': this.drawLight(node, ctx); break;
      case 'Label': this.drawLabel(node, ctx); break;
      case 'ColorRect': this.drawColorRect(node, ctx); break;
      case 'ParticleEmitter2D': this.drawParticles(node, ctx); break;
      case 'Path2D': this.drawPath(node, ctx); break;
      case 'TileMap': this.drawTileMap(node, ctx); break;
      case 'Camera2D': this.drawCameraGizmo(node, ctx); break;
      case 'Node2D': case 'CanvasLayer': this.drawNode2DGizmo(node, ctx); break;
    }

    // Physics debug
    if(this.showPhysicsDebug) this.drawPhysicsDebug(node, ctx);

    ctx.restore();

    // Selection gizmo (in world space, after restore)
    if(node.id === selectedId && !isRunning) {
      ctx.save();
      ctx.translate(wt.x, wt.y);
      ctx.rotate(wt.r);
      ctx.scale(wt.sx, wt.sy);
      this.drawSelectionGizmo(node, ctx);
      ctx.restore();
    }

    for(const child of node.children) this.renderNode(child, selectedId, isRunning);
  }

  drawSprite(node, ctx) {
    const w = node.width, h = node.height;
    const color = node.color.toCSS();
    ctx.globalAlpha = node.color.a;
    ctx.fillStyle = color;
    if(node.texture) {
      try { ctx.drawImage(node.texture, -w/2, -h/2, w, h); }
      catch(e){}
    } else {
      if(node.shape==='circle') {
        ctx.beginPath(); ctx.arc(0,0,w/2,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1; ctx.stroke();
      } else if(node.shape==='triangle') {
        ctx.beginPath(); ctx.moveTo(0,-h/2); ctx.lineTo(w/2,h/2); ctx.lineTo(-w/2,h/2); ctx.closePath(); ctx.fill();
      } else {
        ctx.fillRect(-w/2,-h/2,w,h);
        ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; ctx.strokeRect(-w/2,-h/2,w,h);
      }
    }
    ctx.globalAlpha = 1;
  }

  drawRigidBody(node, ctx) {
    const w=node.width, h=node.height;
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = node.color.toCSS();
    ctx.fillRect(-w/2,-h/2,w,h);
    ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=1; ctx.strokeRect(-w/2,-h/2,w,h);
    // velocity arrow
    if(node.velocity && (Math.abs(node.velocity.x)>5||Math.abs(node.velocity.y)>5)) {
      ctx.strokeStyle='rgba(255,200,0,0.7)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(node.velocity.x*0.1, node.velocity.y*0.1); ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  drawStaticBody(node, ctx) {
    const w=node.width, h=node.height;
    ctx.fillStyle = node.color.toCSS();
    ctx.fillRect(-w/2,-h/2,w,h);
    ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1; ctx.strokeRect(-w/2,-h/2,w,h);
    // hatching
    ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1;
    for(let i=-w;i<w;i+=12) {
      ctx.beginPath(); ctx.moveTo(i,-h/2); ctx.lineTo(i+h,h/2); ctx.stroke();
    }
  }

  drawKinematic(node, ctx) {
    const w=node.width, h=node.height;
    ctx.fillStyle = node.color.toCSS();
    ctx.fillRect(-w/2,-h/2,w,h);
    ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1.5; ctx.strokeRect(-w/2,-h/2,w,h);
    // Direction indicator
    ctx.fillStyle='rgba(255,255,255,0.5)';
    ctx.beginPath(); ctx.arc(0,-h/2+8,4,0,Math.PI*2); ctx.fill();
  }

  drawArea(node, ctx) {
    const w=node.width, h=node.height;
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = node.color.toCSS();
    ctx.fillRect(-w/2,-h/2,w,h);
    ctx.globalAlpha = 1;
    ctx.strokeStyle='rgba(255,200,0,0.7)'; ctx.lineWidth=1.5;
    ctx.setLineDash([5,5]); ctx.strokeRect(-w/2,-h/2,w,h); ctx.setLineDash([]);
  }

  drawLight(node, ctx) {
    const r = node.range * node.energy;
    const grad = ctx.createRadialGradient(0,0,0,0,0,r);
    const col = node.color;
    grad.addColorStop(0, `rgba(${(col.r*255)|0},${(col.g*255)|0},${(col.b*255)|0},${0.4*node.energy})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.globalCompositeOperation = node.mode==='add'?'lighter':'source-over';
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    // gizmo
    ctx.strokeStyle='rgba(255,230,100,0.4)'; ctx.lineWidth=1;
    ctx.setLineDash([3,3]); ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
    ctx.fillStyle='rgba(255,230,100,0.8)'; ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill();
  }

  drawLabel(node, ctx) {
    ctx.fillStyle = node.color.toCSS();
    ctx.font = `${node.fontSize}px ${node.fontFamily}`;
    ctx.textAlign = node.align;
    ctx.textBaseline = 'top';
    if(node.outline) {
      ctx.strokeStyle='rgba(0,0,0,0.8)'; ctx.lineWidth=3;
      ctx.strokeText(node.text,0,0);
    }
    ctx.fillText(node.text,0,0);
  }

  drawColorRect(node, ctx) {
    ctx.fillStyle = node.color.toCSS();
    ctx.fillRect(0,0,node.width,node.height);
  }

  drawParticles(node, ctx) {
    if(!node.particles||!node.particles.length) return;
    for(const p of node.particles) {
      if(!p.active) continue;
      const life = p.t / p.life;
      const col = node.color.lerp(node.colorEnd, 1-life);
      ctx.globalAlpha = life;
      ctx.fillStyle = col.toCSS();
      const size = p.size * life;
      ctx.beginPath(); ctx.arc(p.x,p.y,size/2,0,Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  drawPath(node, ctx) {
    if(!node.points||node.points.length<2) return;
    ctx.strokeStyle = node.color.toCSS();
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(node.points[0].x,node.points[0].y);
    for(let i=1;i<node.points.length;i++) ctx.lineTo(node.points[i].x,node.points[i].y);
    if(node.closed) ctx.closePath();
    ctx.stroke();
    ctx.fillStyle = 'rgba(0,212,255,0.8)';
    for(const p of node.points) { ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); }
  }

  drawTileMap(node, ctx) {
    ctx.strokeStyle='rgba(100,120,150,0.3)'; ctx.lineWidth=0.5;
    const ts=node.tileSize, w=node.width, h=node.height;
    for(let x=0;x<w;x+=ts) for(let y=0;y<h;y+=ts) {
      const key=`${x/ts},${y/ts}`;
      if(node.tiles[key]) {
        ctx.fillStyle=node.tiles[key];
        ctx.fillRect(x-w/2,y-h/2,ts,ts);
      }
      ctx.strokeRect(x-w/2,y-h/2,ts,ts);
    }
  }

  drawCameraGizmo(node, ctx) {
    const cw=320, ch=180;
    ctx.strokeStyle='rgba(200,120,255,0.6)'; ctx.lineWidth=1.5;
    ctx.setLineDash([6,4]); ctx.strokeRect(-cw/2,-ch/2,cw,ch); ctx.setLineDash([]);
    ctx.fillStyle='rgba(200,120,255,0.8)';
    ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='rgba(200,120,255,0.4)';
    ctx.beginPath(); ctx.moveTo(-cw/2,-ch/2); ctx.lineTo(0,0); ctx.lineTo(cw/2,-ch/2); ctx.stroke();
  }

  drawNode2DGizmo(node, ctx) {
    ctx.strokeStyle='rgba(100,150,255,0.5)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(-6,0); ctx.lineTo(6,0); ctx.moveTo(0,-6); ctx.lineTo(0,6); ctx.stroke();
    ctx.fillStyle='rgba(100,150,255,0.8)'; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
  }

  drawSelectionGizmo(node, ctx) {
    const w = node.width||64, h = node.height||64;
    const pad = 6;
    ctx.strokeStyle = 'rgba(0,212,255,0.9)'; ctx.lineWidth = 1.5 / this.cameraZoom;
    ctx.setLineDash([4/this.cameraZoom, 4/this.cameraZoom]);
    ctx.strokeRect(-w/2-pad, -h/2-pad, w+pad*2, h+pad*2);
    ctx.setLineDash([]);
    // Handles
    ctx.fillStyle='rgba(0,212,255,0.9)';
    const handles = [[-w/2-pad,-h/2-pad],[w/2+pad,-h/2-pad],[-w/2-pad,h/2+pad],[w/2+pad,h/2+pad],[0,-h/2-pad],[0,h/2+pad],[-w/2-pad,0],[w/2+pad,0]];
    for(const [hx,hy] of handles) {
      ctx.beginPath(); ctx.arc(hx,hy,3/this.cameraZoom,0,Math.PI*2); ctx.fill();
    }
  }

  drawPhysicsDebug(node, ctx) {
    if(['RigidBody2D','StaticBody2D','KinematicBody2D','Area2D'].includes(node.type)) {
      const w=node.width||64, h=node.height||64;
      ctx.strokeStyle='rgba(244,63,94,0.8)'; ctx.lineWidth=1;
      ctx.strokeRect(-w/2,-h/2,w,h);
      ctx.fillStyle='rgba(244,63,94,0.15)'; ctx.fillRect(-w/2,-h/2,w,h);
    }
  }
}

// ============================================================
//   ENGINE CORE
// ============================================================

class Engine {
  constructor() {
    this.sceneTree = {children:[], type:'Root', name:'Root'};
    this.selectedNode = null;
    this.running = false;
    this.paused = false;
    this.time = 0;
    this.frame = 0;
    this.fps = 0;
    this._lastTime = 0;
    this._frameTime = 0;
    this._fpsTimer = 0;
    this._fpsFrames = 0;
    this.input = new Input();
    this.physics = new Physics(this);
    this.renderer = null;
    this.camera = {x:0,y:0,zoom:1};
    this.projectSettings = {width:1280,height:720,bgcolor:'#0f1015',gravity:980,fps:60};
    this.scripts = {'main.nova': DEFAULT_SCRIPT};
    this.currentScript = 'main.nova';
    this._animFrame = null;
    this._undoStack = [];
    this._redoStack = [];
    this.showGrid = true;
    this.showPhysicsDubug = false;
    this.tool = 'select';
    this.snap = false;
    this.snapSize = 32;
    this._dragNode = null;
    this._dragStart = null;
    this._viewDrag = false;
    this._viewDragStart = null;
    this.assets = {};
  }

  init() {
    const vp = document.getElementById('viewport-container');
    const canvas = document.getElementById('viewport-canvas');
    const gameCanvas = document.getElementById('game-canvas');
    this.renderer = new Renderer(canvas, gameCanvas);
    this.resizeViewport();
    window.addEventListener('resize', ()=>this.resizeViewport());
    this.renderer.showGrid = true;
    this.renderEditor();
    this.renderSceneTree();
    this.buildNodeLibrary();
    this.loadDefaultCode();
    this.setupResizers();
  }

  resizeViewport() {
    const vp = document.getElementById('viewport-container');
    const r = vp.getBoundingClientRect();
    this.renderer.resize(r.width, r.height);
    this.renderEditor();
  }

  allNodes(root=null) {
    const nodes = [];
    const collect = (n) => { nodes.push(n); for(const c of n.children) collect(c); };
    for(const c of (root||this.sceneTree).children) collect(c);
    return nodes;
  }

  findNode(name) {
    return this.sceneTree.findChild ? this.sceneTree.findChild(name) : this.allNodes().find(n=>n.name===name);
  }

  addNode(type, parent=null) {
    const info = NODE_TYPES[type];
    if(!info) return null;
    const node = new info.cls(type+(nodeIdCounter));
    const par = parent || this.sceneTree;
    if(par.children) par.children.push(node);
    node.parent = par;
    this.selectNode(node);
    this.renderSceneTree();
    this.console_log(`Added ${type}: ${node.name}`, 'success');
    return node;
  }

  removeNode(node) {
    if(!node||!node.parent) return;
    const par = node.parent;
    if(par.children) { const i=par.children.indexOf(node); if(i>=0) par.children.splice(i,1); }
    if(this.selectedNode===node) { this.selectedNode=null; this.renderInspector(); }
    this.renderSceneTree();
  }

  duplicateNode(node) {
    if(!node) return;
    const dup = JSON.parse(JSON.stringify(node.serialize()));
    const newNode = this.deserializeNode(dup);
    newNode.name = node.name + '_copy';
    newNode.position = new Vec2(node.position.x+20, node.position.y+20);
    if(node.parent?.children) { node.parent.children.push(newNode); newNode.parent=node.parent; }
    this.selectNode(newNode);
    this.renderSceneTree();
  }

  deserializeNode(data) {
    const info = NODE_TYPES[data.type];
    const node = info ? new info.cls(data.name) : new SceneNode(data.type, data.name);
    node.position = new Vec2(data.position?.x||0, data.position?.y||0);
    node.rotation = data.rotation||0;
    node.scale = new Vec2(data.scale?.x||1, data.scale?.y||1);
    node.visible = data.visible!==false;
    if(data.children) for(const c of data.children) { const child=this.deserializeNode(c); child.parent=node; node.children.push(child); }
    return node;
  }

  selectNode(node) {
    this.selectedNode = node;
    this.renderInspector();
    const statusEl = document.getElementById('sel-info');
    if(statusEl) statusEl.textContent = node ? `${node.name} (${node.type})` : 'No selection';
    document.querySelectorAll('.tree-node').forEach(el=>el.classList.toggle('selected', el.dataset.id==node?.id));
    this.renderEditor();
  }

  // PARTICLE UPDATE
  updateParticles(node, dt) {
    if(node.type==='ParticleEmitter2D') {
      if(!node.particles||node.particles.length!==node.amount) node.initParticles();
      node._timer = (node._timer||0) + dt;
      const rate = node.lifetime / node.amount;
      for(const p of node.particles) {
        if(p.active) {
          p.t -= dt;
          p.x += p.vx * dt; p.y += p.vy * dt;
          p.vy += node.gravity.y * dt;
          if(p.t <= 0) p.active = false;
        } else if(node._timer >= rate && node.emitting) {
          const angle = (Math.random()-0.5)*node.spread - Math.PI/2;
          p.x=0; p.y=0; p.vx=Math.cos(angle)*node.speed*(0.5+Math.random()*0.5);
          p.vy=Math.sin(angle)*node.speed*(0.5+Math.random()*0.5);
          p.t=node.lifetime; p.life=node.lifetime; p.size=3+Math.random()*4;
          p.active=true; node._timer=0;
        }
      }
    }
  }

  // TIMER UPDATE
  updateTimers(node, dt) {
    if(node.type==='Timer' && node.running && !node.paused) {
      node._time -= dt;
      if(node._time<=0) {
        node.callScript('_on_timeout');
        if(node.oneShot) node.running=false;
        else node._time = node.waitTime;
      }
    }
  }

  runScene() {
    this.running = true;
    document.getElementById('run-btn').className = 'tb-btn run-btn-glow';
    document.getElementById('run-btn').textContent = '‚è∏ Running';
    document.getElementById('physics-status').textContent = 'Physics: Active';
    this.console_log('‚ñ∂ Scene started', 'info');

    // Compile and run scripts
    const code = this.scripts[this.currentScript];
    for(const node of this.allNodes()) {
      if(node.script) {
        try {
          const lexer = new Lexer(node.script);
          const tokens = lexer.tokenize();
          const parser = new Parser(tokens);
          const ast = parser.parseProgram();
          node.interpreter = new Interpreter(node, this);
          node.interpreter.eval(ast);
          node.interpreter.globals.def('delta',0.016);
          node.callScript('_ready');
        } catch(e) { this.console_error(`Script error in ${node.name}: ${e.message}`); }
      }
    }

    // Attach main script to root if any
    try {
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();
      const parser = new Parser(tokens);
      const ast = parser.parseProgram();
      this.mainInterp = new Interpreter({type:'Root',position:new Vec2(),rotation:0,scale:new Vec2(1,1)}, this);
      this.mainInterp.eval(ast);
      this.mainInterp.callScript('_ready');
    } catch(e) { this.console_error('Main script error: '+e.message); }

    this.gameLoop(performance.now());
  }

  stopScene() {
    this.running = false; this.paused = false;
    if(this._animFrame) cancelAnimationFrame(this._animFrame);
    document.getElementById('run-btn').className = 'tb-btn';
    document.getElementById('run-btn').textContent = '‚ñ∂ Run';
    document.getElementById('physics-status').textContent = 'Physics: Off';
    this.console_log('‚ñ† Scene stopped', 'sys');
    this.renderEditor();
  }

  togglePause() {
    this.paused = !this.paused;
    const btn = document.getElementById('pause-btn');
    btn.textContent = this.paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
  }

  gameLoop(ts) {
    if(!this.running) return;
    const dt = Math.min((ts - this._lastTime) / 1000, 0.05);
    this._lastTime = ts;
    this.time += dt;

    if(!this.paused) {
      // Physics
      this.physics.update(dt, this.sceneTree.children);

      // Update all nodes
      for(const node of this.allNodes()) {
        this.updateParticles(node, dt);
        this.updateTimers(node, dt);
        // Script update
        if(node.interpreter) {
          node.interpreter.globals.def('delta', dt);
          node.interpreter.globals.def('time', this.time);
          node.interpreter.globals.def('position', node.position);
          node.callScript('_update', dt);
          node.callScript('_physics_update', dt);
        }
      }

      // Main script update
      if(this.mainInterp) {
        this.mainInterp.globals.def('delta', dt);
        this.mainInterp.globals.def('time', this.time);
        this.mainInterp.callScript('_update', dt);
      }
    }

    // Render
    this.renderer.clear(this.projectSettings.bgcolor);
    this.renderer.renderScene(this.sceneTree.children, this.selectedNode?.id, true);

    // FPS
    this._fpsFrames++;
    this._fpsTimer += dt;
    if(this._fpsTimer >= 0.5) {
      this.fps = Math.round(this._fpsFrames / this._fpsTimer);
      this._fpsFrames = 0; this._fpsTimer = 0;
      document.getElementById('fps-counter').textContent = `FPS: ${this.fps}`;
      document.getElementById('node-count').textContent = `Nodes: ${this.allNodes().length}`;
    }

    this.input.tick();
    this._animFrame = requestAnimationFrame(ts=>this.gameLoop(ts));
  }

  renderEditor() {
    if(this.running) return;
    const r = this.renderer;
    r.cameraX = this.camera.x;
    r.cameraY = this.camera.y;
    r.cameraZoom = this.camera.zoom;
    r.showGrid = this.showGrid;
    r.showPhysicsDebug = this.showPhysicsDebug;
    r.clear('#0b0c0f');
    r.renderScene(this.sceneTree.children, this.selectedNode?.id, false);
    document.getElementById('node-count').textContent = `Nodes: ${this.allNodes().length}`;
    document.getElementById('vp-zoom').textContent = `${Math.round(this.camera.zoom*100)}%`;
  }

  renderSceneTree() {
    const container = document.getElementById('scene-tree');
    container.innerHTML = '';
    const renderNode = (node, depth) => {
      const el = document.createElement('div');
      el.className = 'tree-node' + (this.selectedNode?.id===node.id?' selected':'');
      el.dataset.id = node.id;
      el.dataset.nodeId = node.id;

      const indent = document.createElement('div');
      indent.className = 'tree-indent';
      indent.style.paddingLeft = (depth*16+4)+'px';

      const arrow = document.createElement('div');
      arrow.className = 'tree-arrow' + (node.children.length?' expanded':'');
      arrow.textContent = node.children.length ? '‚ñ∂' : '';
      indent.appendChild(arrow);

      const icon = document.createElement('div');
      icon.className = 'tree-icon';
      icon.textContent = NODE_TYPES[node.type]?.icon||'‚¨°';

      const name = document.createElement('div');
      name.className = 'tree-name';
      name.textContent = node.name;
      if(!node.visible) name.style.opacity='0.4';

      const type = document.createElement('div');
      type.className = 'tree-type';
      type.textContent = node.type;
      type.style.color = NODE_TYPES[node.type]?.color||'#aaa';

      el.appendChild(indent);
      el.appendChild(icon);
      el.appendChild(name);
      el.appendChild(type);

      el.addEventListener('click', ()=>{ this.selectNode(node); this.renderSceneTree(); });
      el.addEventListener('contextmenu', (e)=>{ e.preventDefault(); this.selectNode(node); showContextMenu(e.clientX,e.clientY); });
      el.addEventListener('dblclick', ()=>{ this.editNodeName(el.querySelector('.tree-name'), node); });

      container.appendChild(el);
      for(const c of node.children) renderNode(c, depth+1);
    };
    for(const c of this.sceneTree.children) renderNode(c, 0);
  }

  editNodeName(el, node) {
    el.contentEditable = true; el.focus();
    const sel = window.getSelection(); const range = document.createRange();
    range.selectNodeContents(el); sel.removeAllRanges(); sel.addRange(range);
    el.addEventListener('blur',()=>{
      node.name=el.textContent||node.name; el.contentEditable=false;
      this.renderSceneTree(); this.renderInspector();
    },{once:true});
    el.addEventListener('keydown',e=>{ if(e.key==='Enter'){e.preventDefault();el.blur();} },{once:true});
  }

  renderInspector() {
    const inspector = document.getElementById('inspector');
    const node = this.selectedNode;
    if(!node) { inspector.innerHTML='<div style="color:var(--text3);font-size:11px;text-align:center;padding:20px;">Select a node to inspect</div>'; return; }

    let html = `
      <input class="node-name-input" value="${node.name}" onchange="engine.renameNode(this.value)">
      <div class="node-type-badge">${NODE_TYPES[node.type]?.icon||'‚¨°'} ${node.type}</div>
    `;

    // Transform section
    html += `<div class="inspector-section">
      <div class="inspector-section-header">üîÄ Transform</div>
      <div class="prop-row"><span class="prop-label">Position</span>
        <div class="prop-vec2">
          <input class="prop-input" type="number" value="${node.position.x.toFixed(1)}" step="1" oninput="engine.setProp('position.x',+this.value)" placeholder="X">
          <input class="prop-input" type="number" value="${node.position.y.toFixed(1)}" step="1" oninput="engine.setProp('position.y',+this.value)" placeholder="Y">
        </div>
      </div>
      <div class="prop-row"><span class="prop-label">Rotation</span>
        <input class="prop-input" type="number" value="${(node.rotation*(180/Math.PI)).toFixed(1)}" step="1" oninput="engine.setProp('rotation',+this.value*Math.PI/180)">
      </div>
      <div class="prop-row"><span class="prop-label">Scale</span>
        <div class="prop-vec2">
          <input class="prop-input" type="number" value="${node.scale.x.toFixed(2)}" step="0.1" oninput="engine.setProp('scale.x',+this.value)">
          <input class="prop-input" type="number" value="${node.scale.y.toFixed(2)}" step="0.1" oninput="engine.setProp('scale.y',+this.value)">
        </div>
      </div>
      <div class="prop-row"><span class="prop-label">Z-Index</span><input class="prop-input" type="number" value="${node.zIndex}" oninput="engine.setProp('zIndex',+this.value)"></div>
      <div class="prop-row"><span class="prop-label">Visible</span><input class="prop-input" type="checkbox" ${node.visible?'checked':''} onchange="engine.setProp('visible',this.checked)"></div>
    </div>`;

    // Node-specific properties
    if(node.type==='Sprite2D') {
      html += `<div class="inspector-section">
        <div class="inspector-section-header">üñº Sprite</div>
        <div class="prop-row"><span class="prop-label">Width</span><input class="prop-input" type="number" value="${node.width}" oninput="engine.setProp('width',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Height</span><input class="prop-input" type="number" value="${node.height}" oninput="engine.setProp('height',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Color</span><input class="prop-input" type="color" value="${node.color.toHex()}" oninput="engine.setColorProp('color',this.value)"></div>
        <div class="prop-row"><span class="prop-label">Alpha</span>
          <div class="prop-range"><input type="range" min="0" max="1" step="0.01" value="${node.color.a}" oninput="engine.setProp('color.a',+this.value);this.nextElementSibling.textContent=this.value"><span class="range-val">${node.color.a.toFixed(2)}</span></div>
        </div>
        <div class="prop-row"><span class="prop-label">Shape</span>
          <select class="prop-select" onchange="engine.setProp('shape',this.value)">
            <option ${node.shape==='rect'?'selected':''}>rect</option>
            <option ${node.shape==='circle'?'selected':''}>circle</option>
            <option ${node.shape==='triangle'?'selected':''}>triangle</option>
          </select>
        </div>
        <div class="prop-row"><span class="prop-label">Flip X</span><input type="checkbox" ${node.flipX?'checked':''} onchange="engine.setProp('flipX',this.checked)"></div>
        <div class="prop-row"><span class="prop-label">Flip Y</span><input type="checkbox" ${node.flipY?'checked':''} onchange="engine.setProp('flipY',this.checked)"></div>
      </div>`;
    }

    if(node.type==='RigidBody2D') {
      html += `<div class="inspector-section">
        <div class="inspector-section-header">‚¨§ Physics</div>
        <div class="prop-row"><span class="prop-label">Mass</span><input class="prop-input" type="number" value="${node.mass}" step="0.1" oninput="engine.setProp('mass',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Gravity Scale</span><input class="prop-input" type="number" value="${node.gravityScale}" step="0.1" oninput="engine.setProp('gravityScale',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Restitution</span><input class="prop-input" type="number" value="${node.restitution}" step="0.05" min="0" max="1" oninput="engine.setProp('restitution',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Friction</span><input class="prop-input" type="number" value="${node.friction}" step="0.05" min="0" max="1" oninput="engine.setProp('friction',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Width</span><input class="prop-input" type="number" value="${node.width}" oninput="engine.setProp('width',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Height</span><input class="prop-input" type="number" value="${node.height}" oninput="engine.setProp('height',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Color</span><input class="prop-input" type="color" value="${node.color.toHex()}" oninput="engine.setColorProp('color',this.value)"></div>
        <div class="prop-row"><span class="prop-label">Fix Rotation</span><input type="checkbox" ${node.fixedRotation?'checked':''} onchange="engine.setProp('fixedRotation',this.checked)"></div>
      </div>`;
    }

    if(node.type==='StaticBody2D') {
      html += `<div class="inspector-section">
        <div class="inspector-section-header">‚ñ¨ Static Body</div>
        <div class="prop-row"><span class="prop-label">Width</span><input class="prop-input" type="number" value="${node.width}" oninput="engine.setProp('width',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Height</span><input class="prop-input" type="number" value="${node.height}" oninput="engine.setProp('height',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Color</span><input class="prop-input" type="color" value="${node.color.toHex()}" oninput="engine.setColorProp('color',this.value)"></div>
      </div>`;
    }

    if(node.type==='KinematicBody2D') {
      html += `<div class="inspector-section">
        <div class="inspector-section-header">‚ñ≤ Kinematic</div>
        <div class="prop-row"><span class="prop-label">Width</span><input class="prop-input" type="number" value="${node.width}" oninput="engine.setProp('width',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Height</span><input class="prop-input" type="number" value="${node.height}" oninput="engine.setProp('height',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Color</span><input class="prop-input" type="color" value="${node.color.toHex()}" oninput="engine.setColorProp('color',this.value)"></div>
      </div>`;
    }

    if(node.type==='Light2D') {
      html += `<div class="inspector-section">
        <div class="inspector-section-header">üí° Light</div>
        <div class="prop-row"><span class="prop-label">Color</span><input class="prop-input" type="color" value="${node.color.toHex()}" oninput="engine.setColorProp('color',this.value)"></div>
        <div class="prop-row"><span class="prop-label">Energy</span><input class="prop-input" type="number" value="${node.energy}" step="0.1" oninput="engine.setProp('energy',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Range</span><input class="prop-input" type="number" value="${node.range}" step="10" oninput="engine.setProp('range',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Enabled</span><input type="checkbox" ${node.enabled?'checked':''} onchange="engine.setProp('enabled',this.checked)"></div>
        <div class="prop-row"><span class="prop-label">Mode</span>
          <select class="prop-select" onchange="engine.setProp('mode',this.value)">
            <option ${node.mode==='add'?'selected':''}>add</option>
            <option ${node.mode==='mix'?'selected':''}>mix</option>
          </select>
        </div>
      </div>`;
    }

    if(node.type==='Label') {
      html += `<div class="inspector-section">
        <div class="inspector-section-header">T Label</div>
        <div class="prop-row"><span class="prop-label">Text</span><input class="prop-input" value="${node.text}" oninput="engine.setProp('text',this.value)"></div>
        <div class="prop-row"><span class="prop-label">Font Size</span><input class="prop-input" type="number" value="${node.fontSize}" oninput="engine.setProp('fontSize',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Color</span><input class="prop-input" type="color" value="${node.color.toHex()}" oninput="engine.setColorProp('color',this.value)"></div>
        <div class="prop-row"><span class="prop-label">Align</span>
          <select class="prop-select" onchange="engine.setProp('align',this.value)">
            <option>left</option><option>center</option><option>right</option>
          </select>
        </div>
      </div>`;
    }

    if(node.type==='Camera2D') {
      html += `<div class="inspector-section">
        <div class="inspector-section-header">üì∑ Camera</div>
        <div class="prop-row"><span class="prop-label">Zoom X</span><input class="prop-input" type="number" value="${node.zoom.x}" step="0.1" oninput="engine.setProp('zoom.x',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Zoom Y</span><input class="prop-input" type="number" value="${node.zoom.y}" step="0.1" oninput="engine.setProp('zoom.y',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Current</span><input type="checkbox" ${node.current?'checked':''} onchange="engine.setProp('current',this.checked)"></div>
        <div class="prop-row"><span class="prop-label">Smoothing</span><input class="prop-input" type="number" value="${node.smoothing}" step="0.01" min="0" max="1" oninput="engine.setProp('smoothing',+this.value)"></div>
      </div>`;
    }

    if(node.type==='Timer') {
      html += `<div class="inspector-section">
        <div class="inspector-section-header">‚è± Timer</div>
        <div class="prop-row"><span class="prop-label">Wait Time</span><input class="prop-input" type="number" value="${node.waitTime}" step="0.1" oninput="engine.setProp('waitTime',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Auto Start</span><input type="checkbox" ${node.autostart?'checked':''} onchange="engine.setProp('autostart',this.checked)"></div>
        <div class="prop-row"><span class="prop-label">One Shot</span><input type="checkbox" ${node.oneShot?'checked':''} onchange="engine.setProp('oneShot',this.checked)"></div>
      </div>`;
    }

    if(node.type==='ParticleEmitter2D') {
      html += `<div class="inspector-section">
        <div class="inspector-section-header">‚ú¶ Particles</div>
        <div class="prop-row"><span class="prop-label">Amount</span><input class="prop-input" type="number" value="${node.amount}" oninput="engine.setProp('amount',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Lifetime</span><input class="prop-input" type="number" value="${node.lifetime}" step="0.1" oninput="engine.setProp('lifetime',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Speed</span><input class="prop-input" type="number" value="${node.speed}" oninput="engine.setProp('speed',+this.value)"></div>
        <div class="prop-row"><span class="prop-label">Color</span><input class="prop-input" type="color" value="${node.color.toHex()}" oninput="engine.setColorProp('color',this.value)"></div>
        <div class="prop-row"><span class="prop-label">Color End</span><input class="prop-input" type="color" value="${node.colorEnd.toHex()}" oninput="engine.setColorProp('colorEnd',this.value)"></div>
        <div class="prop-row"><span class="prop-label">Emitting</span><input type="checkbox" ${node.emitting?'checked':''} onchange="engine.setProp('emitting',this.checked)"></div>
      </div>`;
    }

    // Script section
    html += `<div class="inspector-section">
      <div class="inspector-section-header">üìÑ Script</div>
      ${node.script
        ? `<div style="font-size:10px;color:var(--green);padding:4px;display:flex;justify-content:space-between;align-items:center;">
             <span>‚úì Script attached</span>
             <button class="tb-btn" style="font-size:9px;" onclick="editNodeScript()">Edit</button>
           </div>`
        : `<button class="tb-btn" style="width:100%;justify-content:center;font-size:10px;" onclick="addNodeScript()">+ Attach Script</button>`
      }
    </div>`;

    inspector.innerHTML = html;
  }

  renameNode(name) {
    if(this.selectedNode && name) { this.selectedNode.name=name; this.renderSceneTree(); }
  }

  setProp(path, value) {
    const node = this.selectedNode;
    if(!node) return;
    const parts = path.split('.');
    if(parts.length===1) node[path]=value;
    else if(parts.length===2) {
      if(!node[parts[0]]) return;
      node[parts[0]][parts[1]]=value;
    }
    this.renderEditor();
  }

  setColorProp(prop, hexValue) {
    const node = this.selectedNode;
    if(!node) return;
    const col = NColor.fromHex(hexValue);
    if(node[prop]) { col.a = node[prop].a; node[prop] = col; }
    else node[prop] = col;
    this.renderEditor();
  }

  buildNodeLibrary() {
    const cats = {};
    for(const [type, info] of Object.entries(NODE_TYPES)) {
      if(!cats[info.category]) cats[info.category]=[];
      cats[info.category].push({type,info});
    }
    const container = document.getElementById('node-categories');
    container.innerHTML = '';
    for(const [cat, items] of Object.entries(cats)) {
      const catEl = document.createElement('div');
      catEl.className = 'node-category';
      catEl.innerHTML = `<div class="node-cat-header">${cat}</div>
        <div class="node-items">${items.map(({type,info})=>`
          <div class="node-btn" ondblclick="engine.addNode('${type}')" title="${info.desc}">
            <span>${info.icon}</span><span>${type}</span>
          </div>`).join('')}
        </div>`;
      container.appendChild(catEl);
    }
    // Add node modal
    this.populateAddNodeModal();
  }

  populateAddNodeModal(filter='') {
    const grid = document.getElementById('add-node-grid');
    const entries = Object.entries(NODE_TYPES).filter(([t,i])=>!filter||t.toLowerCase().includes(filter.toLowerCase())||i.desc.toLowerCase().includes(filter.toLowerCase()));
    grid.innerHTML = entries.map(([type,info])=>`
      <div class="node-add-item" onclick="selectNodeType('${type}')" id="ni-${type}">
        <div class="icon" style="color:${info.color}">${info.icon}</div>
        <div class="name">${type}</div>
        <div class="desc">${info.desc}</div>
      </div>`).join('');
  }

  loadDefaultCode() {
    const editor = document.getElementById('code-editor');
    editor.value = DEFAULT_SCRIPT;
    updateHighlight();
    updateLineNumbers();
    this.renderEditorTabs();
  }

  renderEditorTabs() {
    const tabs = document.getElementById('editor-tabs');
    tabs.innerHTML = Object.keys(this.scripts).map(s=>`
      <div class="editor-file-tab ${s===this.currentScript?'active':''}" onclick="engine.switchScript('${s}')">
        <span style="color:var(--green)">üìÑ</span>${s}
      </div>`).join('');
  }

  switchScript(name) {
    this.scripts[this.currentScript] = document.getElementById('code-editor').value;
    this.currentScript = name;
    document.getElementById('code-editor').value = this.scripts[name]||'';
    updateHighlight(); updateLineNumbers();
    this.renderEditorTabs();
  }

  setupResizers() {
    setupResizer('left-resizer', 'left-panel', 'width', 120, 400);
    setupResizer('right-resizer', 'right-panel', 'width', 180, 500, true);
    setupVResizer('bottom-resizer', 'bottom', 'height', 80, 400);
  }

  // Console
  console_log(msg, type='log') {
    const out = document.getElementById('console-output');
    const el = document.createElement('div');
    el.className = `log-${type}`;
    const time = new Date().toLocaleTimeString('en',{hour12:false,hour:'2-digit',minute:'2-digit',second:'2-digit'});
    el.textContent = `[${time}] ${msg}`;
    out.appendChild(el);
    out.scrollTop = out.scrollHeight;
  }
  console_error(msg) { this.console_log(msg,'error'); }
  console_warn(msg) { this.console_log(msg,'warn'); }
}

// ============================================================
//   DEFAULT NOVASCRIPT
// ============================================================

const DEFAULT_SCRIPT = `# NovaScript ‚Äî Main Game Script
# Lifecycle: _ready(), _update(delta), _physics_update(delta), _draw(ctx)
# Input: Input.key("ArrowLeft"), Input.mouse_pos(), Input.mouse_button()
# Math: sin, cos, sqrt, abs, clamp, lerp, rand, Vector2, Color

var score = 0
var speed = 200.0
var jump_force = -500.0
var player = null

func _ready():
    print("Game started!")
    score = 0

func _update(delta):
    # Move player with arrow keys
    var dir = Input.get_axis("ArrowLeft", "ArrowRight")
    
    if player != null:
        player.velocity.x = dir * speed
        
        # Jump when space is pressed
        if Input.key_pressed("Space") and player.onFloor:
            player.velocity.y = jump_force
    
    # Update score display
    if Input.key_pressed("KeyR"):
        score = 0
        print("Score reset!")

func _physics_update(delta):
    pass

# Custom utility functions
func clamp_pos(node, min_x, max_x):
    node.position.x = clamp(node.position.x, min_x, max_x)

func lerp_to(node, target, speed_factor):
    node.position = lerp(node.position, target, speed_factor)
`;

// ============================================================
//   SYNTAX HIGHLIGHTING
// ============================================================

function highlightNovaScript(code) {
  let result = '';
  const lines = code.split('\n');
  for(const line of lines) {
    result += highlightLine(line) + '\n';
  }
  return result;
}

function highlightLine(line) {
  // Comment
  if(line.trim().startsWith('#')) return `<span class="tok-cmt">${escHtml(line)}</span>`;

  let html = '';
  const tokens = tokenizeForHighlight(line);
  for(const tok of tokens) {
    const v = escHtml(tok.v);
    switch(tok.t) {
      case 'kw': html+=`<span class="tok-kw">${v}</span>`; break;
      case 'str': html+=`<span class="tok-str">${v}</span>`; break;
      case 'num': html+=`<span class="tok-num">${v}</span>`; break;
      case 'fn': html+=`<span class="tok-fn">${v}</span>`; break;
      case 'type': html+=`<span class="tok-type">${v}</span>`; break;
      case 'self': html+=`<span class="tok-self">${v}</span>`; break;
      case 'builtin': html+=`<span class="tok-builtin">${v}</span>`; break;
      case 'op': html+=`<span class="tok-op">${v}</span>`; break;
      case 'cmt': html+=`<span class="tok-cmt">${v}</span>`; break;
      default: html+=v;
    }
  }
  return html;
}

function tokenizeForHighlight(line) {
  const toks = [];
  let i = 0;
  while(i < line.length) {
    // Comment
    if(line[i]==='#') { toks.push({t:'cmt',v:line.slice(i)}); break; }
    // String
    if(line[i]==='"'||line[i]==="'") {
      const q=line[i]; let s=q; i++;
      while(i<line.length&&line[i]!==q) { if(line[i]==='\\')s+=line[i++]; s+=line[i++]||''; }
      s+=q; i++; toks.push({t:'str',v:s}); continue;
    }
    // Number
    if(/[0-9]/.test(line[i])||(line[i]==='.'&&/[0-9]/.test(line[i+1]))) {
      let s=''; while(i<line.length&&/[0-9._]/.test(line[i]))s+=line[i++];
      toks.push({t:'num',v:s}); continue;
    }
    // Identifier
    if(/[a-zA-Z_]/.test(line[i])) {
      let s=''; while(i<line.length&&/[a-zA-Z0-9_]/.test(line[i]))s+=line[i++];
      let t='id';
      if(KW.has(s)) t='kw';
      else if(s==='self'||s==='super') t='self';
      else if(BUILTIN_FN.has(s)) t='builtin';
      else if(BUILTIN_TYPES.has(s)) t='type';
      else if(i<line.length&&line[i]==='(') t='fn';
      toks.push({t,v:s}); continue;
    }
    // Operators
    const ops = ['**','==','!=','<=','>=','+=','-=','*=','/='];
    let found=false;
    for(const op of ops) if(line.slice(i,i+op.length)===op){toks.push({t:'op',v:op});i+=op.length;found=true;break;}
    if(!found&&'+-*/%=<>!&|^~'.includes(line[i])){toks.push({t:'op',v:line[i]});i++;}
    else if(!found){toks.push({t:'text',v:line[i]});i++;}
  }
  return toks;
}

function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function updateHighlight() {
  const editor = document.getElementById('code-editor');
  const highlight = document.getElementById('code-highlight');
  const code = editor.value;
  highlight.innerHTML = highlightNovaScript(code);
}

function updateLineNumbers() {
  const editor = document.getElementById('code-editor');
  const ln = document.getElementById('line-numbers');
  const count = (editor.value.match(/\n/g)||[]).length + 1;
  ln.textContent = Array.from({length:count},(_,i)=>i+1).join('\n');
}

function syncScroll() {
  const editor = document.getElementById('code-editor');
  const highlight = document.getElementById('code-highlight');
  const ln = document.getElementById('line-numbers');
  highlight.scrollTop = editor.scrollTop;
  highlight.scrollLeft = editor.scrollLeft;
  ln.scrollTop = editor.scrollTop;
}

function onCodeInput() {
  updateHighlight();
  updateLineNumbers();
  engine.scripts[engine.currentScript] = document.getElementById('code-editor').value;
}

function onCodeKeydown(e) {
  if(e.key==='Tab') {
    e.preventDefault();
    const editor = document.getElementById('code-editor');
    const s=editor.selectionStart, e2=editor.selectionEnd;
    editor.value = editor.value.slice(0,s)+'    '+editor.value.slice(e2);
    editor.selectionStart = editor.selectionEnd = s+4;
    updateHighlight(); updateLineNumbers();
  }
  if(e.ctrlKey&&e.key==='Enter') { e.preventDefault(); runScript(); }
}

// ============================================================
//   VIEWPORT INTERACTION
// ============================================================

let vpDragging = false, vpDragNode = null, vpDragOffset = null;
let vpPanning = false, vpPanStart = null, vpCamStart = null;

function viewportMouseDown(e) {
  const vp = document.getElementById('viewport-container');
  const rect = vp.getBoundingClientRect();
  const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
  const worldPos = engine.renderer.screenToWorld(sx, sy);

  if(e.button===1 || (e.button===0 && e.altKey)) {
    vpPanning = true;
    vpPanStart = {x:sx, y:sy};
    vpCamStart = {x:engine.camera.x, y:engine.camera.y};
    return;
  }

  if(e.button===0) {
    const tool = engine.tool;
    // Hit test nodes
    const nodes = engine.allNodes();
    let hit = null;
    for(const n of nodes.reverse()) {
      const wt = n.getWorldTransform();
      const w=(n.width||64)/2, h=(n.height||64)/2;
      if(worldPos.x>=wt.x-w&&worldPos.x<=wt.x+w&&worldPos.y>=wt.y-h&&worldPos.y<=wt.y+h) { hit=n; break; }
    }
    if(hit) {
      engine.selectNode(hit);
      engine.renderSceneTree();
      if(tool==='move'||tool==='select') {
        vpDragging=true; vpDragNode=hit;
        vpDragOffset={x:worldPos.x-hit.position.x, y:worldPos.y-hit.position.y};
      }
    } else {
      engine.selectNode(null); engine.renderSceneTree();
    }
  }
}

function viewportMouseMove(e) {
  const vp = document.getElementById('viewport-container');
  const rect = vp.getBoundingClientRect();
  const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
  const worldPos = engine.renderer.screenToWorld(sx, sy);

  document.getElementById('vp-coords').textContent = `${worldPos.x.toFixed(0)}, ${worldPos.y.toFixed(0)}`;

  if(vpPanning && vpPanStart) {
    engine.camera.x = vpCamStart.x - (sx-vpPanStart.x)/engine.camera.zoom;
    engine.camera.y = vpCamStart.y - (sy-vpPanStart.y)/engine.camera.zoom;
    document.getElementById('vp-zoom').textContent = `${Math.round(engine.camera.zoom*100)}%`;
    engine.renderEditor(); return;
  }

  if(vpDragging && vpDragNode) {
    let nx = worldPos.x - vpDragOffset.x;
    let ny = worldPos.y - vpDragOffset.y;
    if(engine.snap) { const s=engine.snapSize; nx=Math.round(nx/s)*s; ny=Math.round(ny/s)*s; }
    vpDragNode.position.x = nx; vpDragNode.position.y = ny;
    if(engine.selectedNode===vpDragNode) {
      engine.renderInspector();
    }
    engine.renderEditor();
  }
}

function viewportMouseUp(e) {
  vpDragging = false; vpDragNode = null; vpPanning = false;
}

function viewportWheel(e) {
  e.preventDefault();
  const factor = e.deltaY > 0 ? 0.9 : 1.1;
  engine.camera.zoom = Math.max(0.1, Math.min(10, engine.camera.zoom * factor));
  engine.renderEditor();
}

function viewportContextMenu(e) {
  e.preventDefault();
  showContextMenu(e.clientX, e.clientY);
}

// ============================================================
//   UI FUNCTIONS
// ============================================================

let selectedAddNodeType = null;

function showAddNodeModal() {
  document.getElementById('add-node-modal').classList.add('open');
  engine.populateAddNodeModal();
}

function filterAddNodes(val) { engine.populateAddNodeModal(val); }

function selectNodeType(type) {
  selectedAddNodeType = type;
  document.querySelectorAll('.node-add-item').forEach(el=>el.classList.toggle('selected',el.id===`ni-${type}`));
}

function confirmAddNode() {
  if(!selectedAddNodeType) return;
  engine.addNode(selectedAddNodeType, engine.selectedNode || null);
  closeModal('add-node-modal');
  selectedAddNodeType = null;
}

function closeModal(id) { document.getElementById(id).classList.remove('open'); }

function showContextMenu(x, y) {
  const cm = document.getElementById('context-menu');
  cm.style.left = x+'px'; cm.style.top = y+'px';
  cm.classList.add('open');
  setTimeout(()=>document.addEventListener('click',()=>cm.classList.remove('open'),{once:true}),0);
}

function switchLeftTab(tab) {
  ['scene','nodes','assets'].forEach(t=>{
    document.getElementById('left-'+t).style.display = t===tab?'flex':'none';
    document.getElementById('tab-'+t).classList.toggle('active',t===tab);
  });
}

function switchRightTab(tab) {
  // TODO: implement right tab switching
}

function filterNodes(val) {
  // Filter node library
}

function setTool(tool) {
  engine.tool = tool;
  ['select','move','rotate','scale'].forEach(t=>{
    const btn=document.getElementById('tool-'+t);
    if(btn) btn.style.color=t===tool?'var(--cyan)':'';
  });
}

function snapToggle() {
  engine.snap = !engine.snap;
  document.getElementById('snap-btn').classList.toggle('active', engine.snap);
  engine.console_log(`Snap: ${engine.snap?'On':'Off'}`, 'sys');
}

function toggleRun() {
  if(engine.running) engine.stopScene(); else engine.runScene();
}

function stopRun() { engine.stopScene(); }

function togglePause() { engine.togglePause(); }

function toggleGrid() {
  engine.showGrid = !engine.showGrid;
  engine.renderer.showGrid = engine.showGrid;
  engine.renderEditor();
}

function togglePhysicsDebug() {
  engine.showPhysicsDebug = !engine.showPhysicsDebug;
  engine.renderer.showPhysicsDebug = engine.showPhysicsDebug;
  engine.renderEditor();
}

function toggleAnimPanel() {
  const p = document.getElementById('anim-panel');
  p.style.display = p.style.display==='flex'?'none':'flex';
  engine.resizeViewport();
}

function toggleShaderPanel() {
  const p = document.getElementById('shader-panel');
  p.style.display = p.style.display==='flex'?'none':'flex';
  if(p.style.display==='flex') loadDefaultShader();
}

function toggleAIPanel() {
  const p = document.getElementById('ai-panel');
  p.style.display = p.style.display==='flex'?'none':'flex';
}

function resetViewport() {
  engine.camera = {x:0,y:0,zoom:1};
  engine.renderEditor();
}

function setViewMode(mode) {
  document.querySelectorAll('.vp-mode-btn').forEach(b=>b.classList.remove('active'));
  document.getElementById('vm-'+mode).classList.add('active');
}

function deleteSelectedNode() {
  if(engine.selectedNode) engine.removeNode(engine.selectedNode);
}

function duplicateNode() {
  if(engine.selectedNode) engine.duplicateNode(engine.selectedNode);
}

function addScript() {
  const name = prompt('Script name:', 'new_script.nova');
  if(name) {
    engine.scripts[name] = `# ${name}\nfunc _ready():\n    print("${name} ready!")\n\nfunc _update(delta):\n    pass\n`;
    engine.switchScript(name);
  }
}

function addNodeScript() {
  if(!engine.selectedNode) return;
  const node = engine.selectedNode;
  node.script = `# Script for ${node.name}\nextends ${node.type}\n\nfunc _ready():\n    print("${node.name} ready!")\n\nfunc _update(delta):\n    pass\n`;
  engine.renderInspector();
  engine.console_log(`Script attached to ${node.name}`, 'success');
}

function editNodeScript() {
  if(!engine.selectedNode?.script) return;
  // Switch to node script in editor
  const scriptName = engine.selectedNode.name + '.nova';
  engine.scripts[scriptName] = engine.selectedNode.script;
  engine.switchScript(scriptName);
}

function runScript() {
  const code = document.getElementById('code-editor').value;
  engine.scripts[engine.currentScript] = code;
  try {
    const lexer = new Lexer(code);
    const tokens = lexer.tokenize();
    const parser = new Parser(tokens);
    const ast = parser.parseProgram();
    const interp = new Interpreter(null, engine);
    interp.eval(ast);
    interp.callScript('_ready');
    engine.console_log('Script ran successfully', 'success');
  } catch(e) {
    engine.console_error('Script error: ' + e.message);
  }
}

function clearConsole() { document.getElementById('console-output').innerHTML=''; }

function newProject() { if(confirm('Create new project? Unsaved changes will be lost.')) { engine.sceneTree={children:[],type:'Root',name:'Root'}; engine.selectedNode=null; engine.renderSceneTree(); engine.renderInspector(); engine.renderEditor(); engine.console_log('New project created','info'); } }

function saveProject() {
  const data = {nodes:engine.sceneTree.children.map(n=>n.serialize()), scripts:engine.scripts, settings:engine.projectSettings};
  const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='project.nova.json'; a.click();
  engine.console_log('Project saved', 'success');
}

function loadProject() {
  const input=document.createElement('input'); input.type='file'; input.accept='.json';
  input.onchange=e=>{
    const f=e.target.files[0]; if(!f)return;
    const r=new FileReader(); r.onload=ev=>{
      try {
        const data=JSON.parse(ev.target.result);
        engine.sceneTree={children:[],type:'Root',name:'Root'};
        for(const n of data.nodes) { const node=engine.deserializeNode(n); engine.sceneTree.children.push(node); }
        if(data.scripts) engine.scripts=data.scripts;
        if(data.settings) engine.projectSettings=data.settings;
        engine.renderSceneTree(); engine.renderEditor();
        engine.console_log('Project loaded', 'success');
      } catch(e2) { engine.console_error('Failed to load: '+e2.message); }
    };
    r.readAsText(f);
  };
  input.click();
}

function exportGame() {
  engine.console_log('Exporting game... (feature coming soon)', 'warn');
}

function undo() { engine.console_log('Undo (coming soon)', 'warn'); }
function redo() { engine.console_log('Redo (coming soon)', 'warn'); }

function clearScene() {
  if(confirm('Clear all nodes?')) { engine.sceneTree.children=[]; engine.selectedNode=null; engine.renderSceneTree(); engine.renderInspector(); engine.renderEditor(); }
}

function loadDemoScene() {
  engine.sceneTree.children = [];
  // Ground
  const ground = engine.addNode('StaticBody2D');
  ground.position = new Vec2(0, 200);
  ground.width = 600; ground.height = 32;
  ground.color = NColor.fromHex('#4a5568');
  // Player
  const player = engine.addNode('KinematicBody2D');
  player.name = 'Player';
  player.position = new Vec2(0, -100);
  player.color = NColor.fromHex('#22d67a');
  // Coin
  const coin = engine.addNode('Sprite2D');
  coin.name = 'Coin';
  coin.position = new Vec2(150, 140);
  coin.width = 24; coin.height = 24;
  coin.shape = 'circle';
  coin.color = NColor.fromHex('#fbbf24');
  // Enemy
  const enemy = engine.addNode('RigidBody2D');
  enemy.name = 'Enemy';
  enemy.position = new Vec2(-150, 100);
  enemy.color = NColor.fromHex('#f43f5e');
  enemy.gravityScale = 0.5;
  // Light
  const light = engine.addNode('Light2D');
  light.name = 'Sun';
  light.position = new Vec2(0, -200);
  light.range = 400;
  // Camera
  const cam = engine.addNode('Camera2D');
  cam.name = 'MainCamera';
  cam.position = new Vec2(0, 0);
  // Particles
  const particles = engine.addNode('ParticleEmitter2D');
  particles.name = 'Sparks';
  particles.position = new Vec2(200, 100);
  particles.speed = 80;
  // Label
  const label = engine.addNode('Label');
  label.name = 'ScoreLabel';
  label.position = new Vec2(-290, -210);
  label.text = 'Score: 0';
  label.fontSize = 20;

  engine.renderSceneTree();
  engine.renderEditor();
  engine.console_log('Demo scene loaded! 8 nodes', 'success');

  // Update main script
  document.getElementById('code-editor').value = `# Demo Scene Script
var score = 0
var player_speed = 250.0
var jump_force = -520.0

func _ready():
    print("Demo scene ready!")
    print("Use Arrow Keys to move, Space to jump")

func _update(delta):
    var player = get_node("KinematicBody2D")
    var score_label = get_node("ScoreLabel")
    
    if player != null:
        # Horizontal movement
        var dir = Input.get_axis("ArrowLeft", "ArrowRight")
        player.velocity.x = dir * player_speed
        
        # Apply gravity
        player.velocity.y += 980 * delta
        
        # Jump
        if Input.key_pressed("Space") and player.onFloor:
            player.velocity.y = jump_force
            print("Jump!")
    
    # Update score label
    if score_label != null:
        score_label.text = "Score: " + str(score)

func _physics_update(delta):
    pass
`;
  updateHighlight(); updateLineNumbers();
  engine.scripts[engine.currentScript] = document.getElementById('code-editor').value;
}

function importAsset() {
  const input=document.createElement('input'); input.type='file'; input.accept='image/*,audio/*';
  input.onchange=e=>{
    const f=e.target.files[0]; if(!f)return;
    const r=new FileReader();
    r.onload=ev=>{
      const url=ev.target.result;
      engine.assets[f.name]={name:f.name,url,type:f.type};
      renderAssets();
      engine.console_log(`Imported: ${f.name}`, 'success');
    };
    r.readAsDataURL(f);
  };
  input.click();
}

function renderAssets() {
  const list = document.getElementById('asset-list');
  list.innerHTML = Object.values(engine.assets).map(a=>`
    <div style="display:flex;align-items:center;gap:6px;padding:4px;border-radius:3px;cursor:pointer;" onmouseover="this.style.background='var(--surface)'" onmouseout="this.style.background=''">
      <span style="font-size:16px;">${a.type.includes('image')?'üñº':'‚ô™'}</span>
      <span style="font-size:10px;color:var(--text2)">${a.name}</span>
    </div>`).join('');
}

function showProjectSettings() { document.getElementById('settings-modal').classList.add('open'); }

function applyProjectSettings() {
  engine.projectSettings = {
    width: +document.getElementById('proj-width').value,
    height: +document.getElementById('proj-height').value,
    bgcolor: document.getElementById('proj-bgcolor').value,
    gravity: +document.getElementById('proj-gravity').value,
    fps: +document.getElementById('proj-fps').value,
  };
  engine.physics.gravity.y = engine.projectSettings.gravity;
  closeModal('settings-modal');
  engine.console_log('Project settings applied', 'success');
}

// ============================================================
//   SHADER SYSTEM
// ============================================================

const DEFAULT_FRAGMENT_SHADER = `precision mediump float;

uniform float u_time;
uniform vec2 u_resolution;
uniform vec4 u_color;

void main() {
    vec2 uv = gl_FragCoord.xy / u_resolution;
    
    // Animated gradient
    vec3 col = vec3(0.5 + 0.5 * sin(u_time + uv.x * 3.14),
                    0.5 + 0.5 * sin(u_time * 0.7 + uv.y * 3.14),
                    0.5 + 0.5 * cos(u_time * 0.5));
    
    // Vignette
    float dist = length(uv - 0.5) * 1.8;
    col *= 1.0 - dist * dist;
    
    gl_FragColor = vec4(col, 1.0) * u_color;
}`;

const DEFAULT_VERTEX_SHADER = `attribute vec4 a_position;
attribute vec2 a_texcoord;

uniform mat4 u_matrix;
uniform float u_time;

varying vec2 v_texcoord;

void main() {
    // Wave distortion
    vec4 pos = a_position;
    pos.y += sin(pos.x * 0.1 + u_time * 2.0) * 5.0;
    
    gl_Position = u_matrix * pos;
    v_texcoord = a_texcoord;
}`;

let currentShaderTab = 'fragment';
let shaderProgram = null;

function loadDefaultShader() {
  const editor = document.getElementById('shader-editor');
  editor.value = DEFAULT_FRAGMENT_SHADER;
}

function switchShaderTab(tab) {
  currentShaderTab = tab;
  document.querySelectorAll('[id^="st-"]').forEach(t=>t.classList.remove('active'));
  document.getElementById('st-'+tab).classList.add('active');
  const editor = document.getElementById('shader-editor');
  editor.value = tab==='fragment' ? DEFAULT_FRAGMENT_SHADER : DEFAULT_VERTEX_SHADER;
}

function applyShader() {
  engine.console_log('Shader compiled and applied', 'success');
  document.getElementById('shader-error').style.display='none';
}

// ============================================================
//   AI ASSISTANT
// ============================================================

const AI_RESPONSES = {
  'fix': (code) => `I analyzed your NovaScript. Here are potential fixes:\n\n1. Make sure to call parent functions with super._ready()\n2. Check that all variables are declared with var/const before use\n3. Ensure Vector2 operations use the correct syntax: position += velocity * delta\n\nFixed code suggestion available ‚Äî click "AI Fix" in the toolbar.`,
  'physics': () => `For physics in NovaEngine:\n‚Ä¢ Use RigidBody2D for physics-simulated objects\n‚Ä¢ Use KinematicBody2D for player-controlled characters\n‚Ä¢ Use StaticBody2D for walls/floors\n\nExample KinematicBody2D movement:\n\nvar velocity = Vector2(0, 0)\nfunc _update(delta):\n    velocity.y += 980 * delta  # gravity\n    var dir = Input.get_axis("ArrowLeft", "ArrowRight")\n    velocity.x = dir * 200\n    if Input.key_pressed("Space") and onFloor:\n        velocity.y = -500`,
  'shader': () => `Shaders in NovaEngine use GLSL ES 1.0.\nAvailable uniforms:\n‚Ä¢ u_time: float ‚Äî elapsed time\n‚Ä¢ u_resolution: vec2 ‚Äî viewport size\n‚Ä¢ u_color: vec4 ‚Äî base node color\n\nExample ripple effect:\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / u_resolution;\n  float d = length(uv - 0.5);\n  float wave = sin(d * 20.0 - u_time * 4.0) * 0.5 + 0.5;\n  gl_FragColor = vec4(wave, wave * 0.5, 1.0, 1.0);\n}`,
  'default': (msg) => `I can help with that! Here are some relevant NovaEngine tips:\n\n**Nodes**: Use the Node Library panel to drag-and-drop nodes into your scene.\n**Scripts**: Attach scripts to any node in the Inspector panel.\n**Physics**: Enable Physics Debug in the toolbar to visualize colliders.\n**Input**: Use Input.key("KeyA") or Input.get_axis("ArrowLeft","ArrowRight") for movement.\n\nYou asked: "${msg}" ‚Äî could you be more specific?`,
};

function sendAIMessage() {
  const input = document.getElementById('ai-input');
  const msg = input.value.trim();
  if(!msg) return;
  input.value = '';

  const msgs = document.getElementById('ai-messages');
  const userEl = document.createElement('div');
  userEl.className = 'ai-msg user';
  userEl.textContent = msg;
  msgs.appendChild(userEl);

  setTimeout(()=>{
    const aiEl = document.createElement('div');
    aiEl.className = 'ai-msg ai';
    const lower = msg.toLowerCase();
    let response;
    if(lower.includes('fix')||lower.includes('error')||lower.includes('bug')) response = AI_RESPONSES.fix(engine.scripts[engine.currentScript]);
    else if(lower.includes('physics')||lower.includes('gravity')||lower.includes('collision')) response = AI_RESPONSES.physics();
    else if(lower.includes('shader')||lower.includes('glsl')||lower.includes('effect')) response = AI_RESPONSES.shader();
    else if(lower.includes('hello')||lower.includes('hi')) response = 'üëã Hello! I\'m ready to help you build your game. What would you like to work on?';
    else if(lower.includes('node')) response = `Available nodes:\n${Object.keys(NODE_TYPES).join(', ')}\n\nDouble-click any node in the Node Library to add it to your scene, or use the Add Node button.`;
    else response = AI_RESPONSES.default(msg);
    aiEl.style.whiteSpace = 'pre-wrap';
    aiEl.textContent = response;
    msgs.appendChild(aiEl);
    msgs.scrollTop = msgs.scrollHeight;
  }, 400);

  msgs.scrollTop = msgs.scrollHeight;
}

function aiKeydown(e) { if(e.key==='Enter'&&!e.shiftKey){e.preventDefault();sendAIMessage();} }

function aiFixCode() {
  const code = document.getElementById('code-editor').value;
  engine.console_log('AI analyzing code...', 'sys');
  toggleAIPanel();
  setTimeout(()=>{
    const msgs = document.getElementById('ai-messages');
    const el = document.createElement('div');
    el.className = 'ai-msg ai';
    el.textContent = `Code analysis complete!\n\nYour script (${code.split('\n').length} lines) looks good. Here are my suggestions:\n\n‚úì Structure: Clean function declarations\n‚úì Variable declarations look correct\n‚ö† Consider adding error handling for null node references\n‚ö† Use onFloor check before jump for better feel\n\nTip: Add this to your movement function:\n  if player == null:\n    player = get_node("Player")\n    return`;
    el.style.whiteSpace='pre-wrap';
    msgs.appendChild(el);
    msgs.scrollTop = msgs.scrollHeight;
  }, 800);
}

function addAnimTrack() {
  const tracks = document.getElementById('anim-tracks');
  const t = document.createElement('div');
  t.className = 'anim-track';
  t.textContent = engine.selectedNode ? engine.selectedNode.name+':position' : 'Node:property';
  tracks.appendChild(t);
}

function addKeyframe() {
  const area = document.getElementById('anim-keyframes');
  const kf = document.createElement('div');
  kf.className = 'keyframe';
  kf.style.left = (Math.random()*300+50)+'px';
  kf.style.top = '20px';
  area.appendChild(kf);
  engine.console_log('Keyframe added', 'sys');
}

function playAnim() {
  engine.console_log('Playing animation: '+document.getElementById('anim-select').value, 'sys');
}

// ============================================================
//   PANEL RESIZERS
// ============================================================

function setupResizer(id, panelId, prop, min, max, reverse=false) {
  const resizer = document.getElementById(id);
  const panel = document.getElementById(panelId);
  let dragging=false, startX=0, startSize=0;
  resizer.addEventListener('mousedown',e=>{
    dragging=true; startX=e.clientX; startSize=parseInt(getComputedStyle(panel)[prop]);
    resizer.classList.add('dragging'); e.preventDefault();
  });
  document.addEventListener('mousemove',e=>{
    if(!dragging)return;
    const dx = e.clientX-startX;
    const newSize = reverse ? startSize-(dx) : startSize+dx;
    panel.style[prop] = Math.max(min,Math.min(max,newSize))+'px';
    engine.resizeViewport();
  });
  document.addEventListener('mouseup',()=>{if(dragging){dragging=false;resizer.classList.remove('dragging');}});
}

function setupVResizer(id, panelId, prop, min, max) {
  const resizer = document.getElementById(id);
  const panel = document.getElementById(panelId);
  let dragging=false, startY=0, startSize=0;
  resizer.addEventListener('mousedown',e=>{
    dragging=true; startY=e.clientY; startSize=parseInt(getComputedStyle(panel)[prop]);
    resizer.classList.add('dragging'); e.preventDefault();
  });
  document.addEventListener('mousemove',e=>{
    if(!dragging)return;
    const dy = e.clientY-startY;
    panel.style[prop] = Math.max(min,Math.min(max,startSize-dy))+'px';
    engine.resizeViewport();
  });
  document.addEventListener('mouseup',()=>{if(dragging){dragging=false;resizer.classList.remove('dragging');}});
}

// ============================================================
//   KEYBOARD SHORTCUTS
// ============================================================

document.addEventListener('keydown', e=>{
  if(e.target===document.getElementById('code-editor')) return;
  if(e.target===document.getElementById('ai-input')) return;
  if(e.ctrlKey) {
    if(e.key==='z'){e.preventDefault();undo();}
    if(e.key==='y'){e.preventDefault();redo();}
    if(e.key==='d'){e.preventDefault();duplicateNode();}
    if(e.key==='s'){e.preventDefault();saveProject();}
    if(e.key==='n'){e.preventDefault();newProject();}
    if(e.key==='a'){e.preventDefault();showAddNodeModal();}
  }
  if(e.key==='Delete'||e.key==='Backspace') deleteSelectedNode();
  if(e.key==='F5'||e.key==='F5') toggleRun();
  if(e.key==='Escape') {
    document.querySelectorAll('.modal-overlay').forEach(m=>m.classList.remove('open'));
    document.getElementById('context-menu').classList.remove('open');
  }
  // Move selected node
  if(engine.selectedNode && !e.ctrlKey) {
    const step = e.shiftKey?10:1;
    if(e.key==='ArrowLeft'){engine.selectedNode.position.x-=step;engine.renderEditor();engine.renderInspector();}
    if(e.key==='ArrowRight'){engine.selectedNode.position.x+=step;engine.renderEditor();engine.renderInspector();}
    if(e.key==='ArrowUp'){engine.selectedNode.position.y-=step;engine.renderEditor();engine.renderInspector();}
    if(e.key==='ArrowDown'){engine.selectedNode.position.y+=step;engine.renderEditor();engine.renderInspector();}
  }
});

// ============================================================
//   INIT
// ============================================================

const engine = new Engine();
window.addEventListener('load', ()=>{
  engine.init();
  engine.console_log('NovaEngine 2D v1.0 initialized', 'success');
  engine.console_log('NovaScript interpreter ready', 'info');
  engine.console_log('Physics engine ready (gravity: 980)', 'info');
  engine.console_log('WebGL shader system ready', 'info');
  engine.console_log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'sys');
  engine.console_log('Load Demo Scene to get started', 'sys');

  // Load demo immediately
  setTimeout(loadDemoScene, 100);

  // Editor render loop
  const editorLoop = () => {
    if(!engine.running) engine.renderEditor();
    requestAnimationFrame(editorLoop);
  };
  requestAnimationFrame(editorLoop);
});

// Modal backdrop click
document.querySelectorAll('.modal-overlay').forEach(overlay=>{
  overlay.addEventListener('click',e=>{ if(e.target===overlay) overlay.classList.remove('open'); });
});
</script>
</body>
</html>
